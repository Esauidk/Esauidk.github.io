<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>3D Lighting on Esau's Page</title><link>/categories/3d-lighting/</link><description>Recent content in 3D Lighting on Esau's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 22 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/3d-lighting/index.xml" rel="self" type="application/rss+xml"/><item><title>3D Graphics: Light Reflection Models</title><link>/p/3d-graphics-light-reflection-models/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-light-reflection-models/</guid><description>&lt;img src="https://academyofanimatedart.com/wp-content/uploads/2019/03/td-u-CG-lighting-shadows-light-shading-featured.jpg" alt="Featured image of post 3D Graphics: Light Reflection Models" />&lt;p>Naturally photons/light bounces on impact with surfaces, but how does it bouce off?&lt;/p>
&lt;h1 id="mirrorslight-models">Mirrors/Light Models&lt;/h1>
&lt;p>Mirros are the best example of how light reflects, when something is viewed through a mirror it is flipped along the z-axis&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/light.png"
width="500"
height="294"
srcset="/p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Light"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>In terms on how to calculate the light reflected to a view, there are many different types of light reflection models&lt;/p>
&lt;h3 id="variables">Variables&lt;/h3>
&lt;p>$I_V =$ Light intesity for viewer&lt;/p>
&lt;p>$I_L =$ Light intensity from source&lt;/p>
&lt;p>$V =$ Viewing vector&lt;/p>
&lt;p>$R =$ Reflection vector&lt;/p>
&lt;p>$N =$ Normal Vector&lt;/p>
&lt;h2 id="phong-reflection-specular">Phong Reflection (Specular)&lt;/h2>
&lt;p>This uses the reflection of the light vector and the angle between the reflection and the veiwing vector to determine the intensity of light that the camera/viewer sees&lt;/p>
&lt;p>$$I_V = I_L * (V \cdot R)^a$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/phong.png"
width="800"
height="282"
srcset="/p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="phong"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="680px"
>&lt;/p>
&lt;h2 id="blinn-phong-specular">Blinn-Phong (Specular)&lt;/h2>
&lt;p>Instead of using the angle between the reflection and viewer, Blinn-Phong uses the angle between the half vector of the light vector and view vector ($H = L + V$)&lt;/p>
&lt;p>$$I_V = I_L * (N \cdot H)^a$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/blinn-phong.png"
width="600"
height="402"
srcset="/p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bphong"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;h2 id="lambertian-reflectiondiffuse">Lambertian Reflection(Diffuse)&lt;/h2>
&lt;p>This type of reflection represents when light equally gets spread in all directions in oppose to the other light models that represent when light gets spread unevenly depending on the viewing angle&lt;/p>
&lt;p>$$I_O = I_L * N \cdot L$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/diffuse.png"
width="594"
height="244"
srcset="/p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="diffuse"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;h2 id="ambient-light">Ambient Light&lt;/h2>
&lt;p>Ambient light is the light that exists after infinite amounts of reflections. You can view it as the &amp;ldquo;light in the room&amp;rdquo;. Since it is a result from infinite amounts of reflections, it is normally treated as a predefined constant&lt;/p>
&lt;h1 id="diffuse--specular">Diffuse &amp;amp; Specular&lt;/h1>
&lt;p>To make it clear, diffuse light models focus on when light on impact spreads evenly in all directions while specular focuses on when light is spread more intense in certain directions.&lt;/p>
&lt;p>This is not a 1 or the other phenomenon. These light models(specular &amp;amp; diffuse) both happen at the same time in real life. For example an apple refuses to absorb the color red and spreads it out evenly in all directions, but the layer of wax around it just reflects the light specularly. We have both specular light and diffuse light happening at the same time!&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/apple.png"
width="1090"
height="802"
srcset="/p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="apple"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="326px"
>&lt;/p>
&lt;h1 id="light-model">Light Model&lt;/h1>
&lt;p>Since we know that light is the combination of ambient, specular, and diffuse lighting, we can view the equation for light to be like this:&lt;/p>
&lt;p>$$I = I_{La} + I_L * (N \cdot H)^a + I_L * (N \cdot L)$$
$I_{La}$ = Ambient light Inensity&lt;/p>
&lt;p>Light is additive, meaning multiple lights just get added together&lt;/p>
&lt;p>$$I = I_{La} + \sum_{j} I_{L_{j}} * (N \cdot H_{j})^a + {I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$$&lt;/p>
&lt;p>There are also specific scalers that define the properities of the object used in the light model
$k_d=$ diffusal color
$k_s=$ specular color
a = specular shininess&lt;/p>
&lt;p>$$I = I_{La} + \sum_{j} k_s * I_{L_{j}} * (N \cdot H_{j})^a + k_d *{I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$$&lt;/p>
&lt;h2 id="attenuation">Attenuation&lt;/h2>
&lt;p>To add on to the light model, light follows a pheonomenon known as the &lt;em>Inverse Square Rule&lt;/em>. This rule is as light spreads farther out from the source, the intesnity of it decreases inversly of the square distance&lt;/p>
&lt;p>$$I_L = \frac{I_{s}}{4 * \pi * r^2}$$&lt;/p>
&lt;p>$s=$ source
$r$ = radius from source&lt;/p>
&lt;p>Attenuation is a variation of the inverse square rule that lets us define an approximation of the intensity decay&lt;/p>
&lt;p>$$I_L = \frac{I_{s}}{ar^2+br + c}$$
$a$, $b$, $c$ are constants that can be changed to fit the right intensity decay model desired&lt;/p></description></item><item><title>3D Graphics: Accelerated RayTracing</title><link>/p/3d-graphics-accelerated-raytracing/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-accelerated-raytracing/</guid><description>&lt;img src="https://blogs.nvidia.com/wp-content/uploads/2019/06/rtx-on-off.png" alt="Featured image of post 3D Graphics: Accelerated RayTracing" />&lt;p>Tatics that enhanced and accelerated raytracing&lt;/p>
&lt;h1 id="anti-aliasing">Anti-Aliasing&lt;/h1>
&lt;p>Aliasing is when the change between pixels is too sudden to be realistic to the image, creating a unrealistic image. In raytracing this can happen when not enough rays are sampled for a pixel.
&lt;img src="/p/3d-graphics-accelerated-raytracing/alias.png"
width="437"
height="274"
srcset="/p/3d-graphics-accelerated-raytracing/alias_hu7c5a63f5e63e1fd56eb0181a28fc044b_18970_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/alias_hu7c5a63f5e63e1fd56eb0181a28fc044b_18970_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="alias"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
>&lt;/p>
&lt;h2 id="super-sampling">Super Sampling&lt;/h2>
&lt;p>Aliasing occurs when the sampling (i.e. shooting rays) is down too far apart, leading to certain areas of a pixel which could have a different value not being sampled&lt;/p>
&lt;h3 id="adaptive-sampling">Adaptive Sampling&lt;/h3>
&lt;p>The basic idea of adaptive sampling is to add more sample points (rays) in areas that show indications of inbetween values not being sampled
&lt;img src="/p/3d-graphics-accelerated-raytracing/supersample.png"
width="704"
height="606"
srcset="/p/3d-graphics-accelerated-raytracing/supersample_hudcbb9222eee54f0c640f69286926d800_95137_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/supersample_hudcbb9222eee54f0c640f69286926d800_95137_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="supersampling"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;h3 id="distribution-raycasting">Distribution Raycasting&lt;/h3>
&lt;p>Instead of adding more rays to get the correct sample, we can use a distribution (specifically the poisson distribution) to determine the best place on the pixel to sample our ray&lt;/p>
&lt;h1 id="acceleration">Acceleration&lt;/h1>
&lt;h2 id="ray-polyhedron-intersection">Ray-Polyhedron Intersection&lt;/h2>
&lt;p>There are many ways to handle intersection with triangle based objects&lt;/p>
&lt;h3 id="bounding-volume">Bounding Volume&lt;/h3>
&lt;p>You can using a bounding volume to determine if you are touching an object. This allows you to use primitives to determine intersection while costing accuracy&lt;/p>
&lt;h4 id="bounding-voluming-hierarchy">Bounding Voluming Hierarchy&lt;/h4>
&lt;p>Instead of &lt;strong>only&lt;/strong> giving the overall object a bounding volume, you can do a hierarichal tree of boudning volumes that also seperate pieces of the objects in volumes&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-accelerated-raytracing/dragon.png"
width="1280"
height="720"
srcset="/p/3d-graphics-accelerated-raytracing/dragon_hubbe6c356053ad4498b86e7fb8a0d2339_708993_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/dragon_hubbe6c356053ad4498b86e7fb8a0d2339_708993_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="dragon"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-accelerated-raytracing/bounding.png"
width="1000"
height="313"
srcset="/p/3d-graphics-accelerated-raytracing/bounding_huded67bc138525de7a7451f6725a804d7_46049_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/bounding_huded67bc138525de7a7451f6725a804d7_46049_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bounding"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="766px"
>&lt;/p>
&lt;h3 id="spatial-subdivision">Spatial Subdivision&lt;/h3>
&lt;h5 id="uniform">Uniform&lt;/h5>
&lt;p>The idea of spatial subdivision is to divide the world space into cells uniformally and tying objects to the cells it overlaps
&lt;img src="/p/3d-graphics-accelerated-raytracing/uniformDivision.png"
width="1390"
height="642"
srcset="/p/3d-graphics-accelerated-raytracing/uniformDivision_hu630c555f0592f9057c4a6f4706e1796f_243742_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/uniformDivision_hu630c555f0592f9057c4a6f4706e1796f_243742_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="uniformSpace"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;h5 id="non-uniform">Non-Uniform&lt;/h5>
&lt;p>As the name suggests, it&amp;rsquo;s the same idea of the uniform method but with the cells being non-uniformally subdivided
&lt;img src="/p/3d-graphics-accelerated-raytracing/nonUniformDivision.png"
width="1436"
height="630"
srcset="/p/3d-graphics-accelerated-raytracing/nonUniformDivision_hu272fdaceef125a4de6fe95eb172004a4_213158_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/nonUniformDivision_hu272fdaceef125a4de6fe95eb172004a4_213158_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="nonUniformSpace"
class="gallery-image"
data-flex-grow="227"
data-flex-basis="547px"
>&lt;/p></description></item><item><title>3D Graphics: RayTracing Intro</title><link>/p/3d-graphics-raytracing-intro/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-raytracing-intro/</guid><description>&lt;img src="https://i.ytimg.com/vi/Xs0WOuToefw/maxresdefault.jpg" alt="Featured image of post 3D Graphics: RayTracing Intro" />&lt;p>Raytracing is a form of light reflection calculation that allows shadows to be calculated and recieve more exact versions of light intensities&lt;/p>
&lt;h2 id="basic-raytracing">Basic Raytracing&lt;/h2>
&lt;p>We care about the rays of light that the sun emits and bounce around before hitting our eye. The sun emits millions of rays of light that never hit our eye so if we calculated all the rays of the sun, we would be wasting many computing cycles&lt;/p>
&lt;p>What is actually done in basic raytracing is to actually emit from the target (our vew/camera) and see which ray actually reaches the sun. We can set a limit on the number of reflections until we want to drop a ray and this let&amp;rsquo;s us calculate only the rays we care about&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-raytracing-intro/trace.png"
width="450"
height="383"
srcset="/p/3d-graphics-raytracing-intro/trace_hu031b6403895bc5f288de39d80fcd787e_37881_480x0_resize_box_3.png 480w, /p/3d-graphics-raytracing-intro/trace_hu031b6403895bc5f288de39d80fcd787e_37881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="trace"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="281px"
>&lt;/p>
&lt;h3 id="shadows">Shadows&lt;/h3>
&lt;p>In terms of shadows, there are two different types of shadows: hard shadow &amp;amp; soft shadow&lt;/p>
&lt;ul>
&lt;li>Hard Shadow: No light ever hits the particular spot&lt;/li>
&lt;li>Soft Shadow: Some light hits the spot but not all&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/p/3d-graphics-raytracing-intro/shadows.png"
width="380"
height="488"
srcset="/p/3d-graphics-raytracing-intro/shadows_hubc4c066f187a9122b37857bfdbb88c62_16009_480x0_resize_box_3.png 480w, /p/3d-graphics-raytracing-intro/shadows_hubc4c066f187a9122b37857bfdbb88c62_16009_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="shadow"
class="gallery-image"
data-flex-grow="77"
data-flex-basis="186px"
>&lt;/p>
&lt;h3 id="raytracing-psuedocode">Raytracing PsuedoCode&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Calculating all the rays&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># find intersection&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">intersect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># using the halfway point to calculate the reflection&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># (a + b)/2 = c &amp;amp;&amp;amp; -(c * 2) + a = b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reflection&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#calculate the rotation of the current ray for the internal boucing of the object (ie: Figure out refraction ray)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">internalRay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SnellLaw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Get light intensity (light model: Specular + Diffuse + Ambience )&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">shade&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># reflection ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">+&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">specularColor&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">reflection&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># refraction ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">+&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">trasnmissive&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">inernalRay&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># performing ray tracing on the image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">traceImage&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">pixel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">translateFromProjectionToWorld&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">direction&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">camera&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span> &lt;span class="n">mag&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">camera&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixel&lt;/span> &lt;span class="n">world&lt;/span> &lt;span class="n">positiion&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># finding the intersection of a ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">intersect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">distance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">Example&lt;/span> &lt;span class="k">with&lt;/span> &lt;span class="n">sphere&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">object&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">INTERSECTION&lt;/span> &lt;span class="n">CONFIRMED&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">shade&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Grab the color of the object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">diffuseColor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Go for every light hitting this object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lights&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># calculate the attenuation of this point (both by distance and shadow)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attenuation&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">distanceAtten&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shadowAtten&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># get the direcetion of the light to the point&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">L&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getDirection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Do diffusion, specular, and ambient lighting&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">intensity&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ambient&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">attenuation&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">diffuse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">specular&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Return the final light intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="detecting-intersection">Detecting Intersection&lt;/h3>
&lt;p>A current point on a ray can be represented using the function
$$R(t) = P_0 + t\vec{d}$$
This is a function that will produce a point for us that we can immediately use to verify for intersection. Now we need a primitive to verify against. A simple example is using a sphere!&lt;/p>
&lt;h4 id="sphere">Sphere&lt;/h4>
&lt;p>We can represent a sphere using the equation:
$$x^2+y^2+z^2=r^2$$
This equation does two things, tells us the radius if we know a point on the sphere, but it also tells us whether something is on the same sphere if we only know the radius and need to confirm the points&lt;/p>
&lt;p>Using both equations, we can rewrite it into a solving for zero problem:&lt;/p>
&lt;p>$$x^2+y^2+z^2-r^2=0$$
Since we can produce the x,y, and z with our ray problem, we can turn it into a problem involving only one unknown variable, t!
$$(P_0x + t\vec{d_x})^2 + (P_0y + t\vec{d_y})^2 + (P_0z + t\vec{d_z})^2 - r^2 = 0 $$
Now before we call this good, we have to note, this equation will only tell us if a point lies exactly on the sphere. We want to also be able to tell if point is inside the sphere. We call solve this by turning this into an inequality&lt;/p>
&lt;p>$$(P_0x + t\vec{d_x})^2 + (P_0y + t\vec{d_y})^2 + (P_0z + t\vec{d_z})^2 - r^2 \leq 0 $$
&lt;strong>Disclaimer&lt;/strong>: This assumes the sphere starts at the origin (0,0,0), you will have to take that into account when using with a sphere not at the origin:
$$(x-a)^2+(y-b)^2+(z-c)^2=r^2$$
$a$,$b$,$c$ = sphere origin position&lt;/p>
&lt;h4 id="plane">Plane&lt;/h4>
&lt;p>Unlike spheres, we don&amp;rsquo;t have a nice clean equation to verify our points, we need to do vector maths&lt;/p>
&lt;p>We know that all points on a plane have the same normal, this means any vector we make using two points on the plane should be perpendicular to the normal!&lt;/p>
&lt;p>We can represent our verification fuction as:&lt;/p>
&lt;p>&lt;strong>with Q being the point generated from $R(t)$ and P being a point on the plane&lt;/strong>&lt;/p>
&lt;p>$$\vec{N} \cdot (Q - P)=0$$&lt;/p>
&lt;p>0 represents the normal and the vector derived with two points being perpendicular, anything else means it does not lie on the plane. &lt;strong>Note:&lt;/strong> Any point on the plane can be used to generate the $(Q-P)$ vector, as long as it&amp;rsquo;s normalized.&lt;/p></description></item></channel></rss>