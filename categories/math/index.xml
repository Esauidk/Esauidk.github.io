<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Esau's Page</title><link>/categories/math/</link><description>Recent content in Math on Esau's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 23 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/math/index.xml" rel="self" type="application/rss+xml"/><item><title>3D Graphics Intro</title><link>/p/3d-graphics-intro/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-intro/</guid><description>&lt;img src="https://i.stack.imgur.com/Bk826.png" alt="Featured image of post 3D Graphics Intro" />&lt;p>A mesh is a collection of primitives shape that make up an overarching model
&lt;img src="/p/3d-graphics-intro/mesh.png"
width="1000"
height="1080"
srcset="/p/3d-graphics-intro/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_480x0_resize_box_3.png 480w, /p/3d-graphics-intro/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Mesh"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="222px"
>&lt;/p>
&lt;h2 id="storing-mesh-data">Storing Mesh Data&lt;/h2>
&lt;h3 id="storing-mesh">Storing Mesh&lt;/h3>
&lt;p>To efficiently store mesh data, we want to reduce the amount of redundancy when rendering the primitive shapes.&lt;/p>
&lt;p>We do this by storing all the verticies of involved in the mesh and storing all the different combination of the verticies that make up our primitive shape&lt;/p>
&lt;p>Vertice Data
[V_0, V_1, V_2, &amp;hellip; , V_n]&lt;/p>
&lt;p>Primitive Shape Data
[ [0, 1, 2], [ 3, 4, 5], &amp;hellip; [n-2, n-1, n] ]&lt;/p>
&lt;h3 id="vertex-order-matters">Vertex Order Matters&lt;/h3>
&lt;p>In practice, the order of the verticies of a mesh is used to determine the &lt;strong>normal&lt;/strong> (an indication of which side of the primitive is the front and back). Putting the verticies in the wrong order can get results that are unexpected&lt;/p>
&lt;h3 id="culling">Culling&lt;/h3>
&lt;p>Culling is a technique used to reduce the amount of primitve shapes being rendered by the render engine. It expects to render only one side of the primitve shape, the front side! (Unless specified that it&amp;rsquo;s double sided).&lt;/p>
&lt;p>Determining the side of the primitve is done through vector math!&lt;/p>
&lt;p>&lt;strong>Calculating the angle:&lt;/strong>&lt;/p>
&lt;p>Cos(ϴ) = -V * N&lt;/p>
&lt;p>V = viewing vector (from the camera to the object)&lt;/p>
&lt;p>N = normal vector&lt;/p>
&lt;p>ϴ &amp;gt; 0 = front facing
ϴ &amp;lt;= 0 = back facing&lt;/p>
&lt;p>Having the wrong normals can cause a triangle to not be rendered&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-intro/wrongIndex.png"
width="450"
height="193"
srcset="/p/3d-graphics-intro/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_480x0_resize_box_3.png 480w, /p/3d-graphics-intro/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="indexDif"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="559px"
>&lt;/p>
&lt;h3 id="storing-normals">Storing Normals&lt;/h3>
&lt;p>Normals could be calculated per triangle using some math, but that would introduce problems when wanting to create smooth surfraces of multiple primitives.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-intro/interpResult.png"
width="670"
height="355"
srcset="/p/3d-graphics-intro/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_480x0_resize_box_3.png 480w, /p/3d-graphics-intro/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="interpResult"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="452px"
>&lt;/p>
&lt;p>To avoid this issue, we give every &lt;strong>vertex&lt;/strong> a normal vector and interpolate normal vectors intermediate points on the primitive&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-intro/normalInterpolation.png"
width="670"
height="247"
srcset="/p/3d-graphics-intro/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_480x0_resize_box_3.png 480w, /p/3d-graphics-intro/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="normalInterp"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="651px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
[ [V_0, N_0], [V_1, N_1], [V_2, N_2], &amp;hellip; , [V_n, N_n] ]&lt;/p>
&lt;h3 id="storing-textures">Storing Textures&lt;/h3>
&lt;p>We have an object with a correct shape, but what if we want to paint it with an image? This is done through the power of UV mapping.&lt;/p>
&lt;p>UV mapping is the process of assign a pixel on the texture/image with a pixel on the model. We assign a vertex on our mesh with a 2D coordinate corresponding a pixel on the texture. Other UV positions on the non-vertex mesh pixels are interpolated.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-intro/UVMapping.png"
width="640"
height="336"
srcset="/p/3d-graphics-intro/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_480x0_resize_box_3.png 480w, /p/3d-graphics-intro/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UVMapping"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="457px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
[ [V_0, N_0, (U,V)_0], [V_1, N_1, (U,V)_1], [V_2, N_2, (U,V)_3], &amp;hellip; , [V_n, N_n, (U,V)_n] ]&lt;/p></description></item><item><title>3D Graphics: Hierarchy Models</title><link>/p/3d-graphics-hierarchy-models/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-hierarchy-models/</guid><description>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png" alt="Featured image of post 3D Graphics: Hierarchy Models" />&lt;h2 id="matrix-transformation">Matrix Transformation&lt;/h2>
&lt;p>The reason we keep things like translations as a matrix transformation instead of a simple collumn addition is for &lt;strong>EFFICIENCY&lt;/strong>.&lt;/p>
&lt;p>If we wanted to do multiple transformations on an objects.&lt;/p>
&lt;p>$$(M_N * &amp;hellip; * M_1) * P $$&lt;/p>
&lt;p>is easier than&lt;/p>
&lt;p>$$(M_2 * ((M_1 * P ) + T_1) + T_2)$$&lt;/p>
&lt;p>We can calculate the overall matrix onces instead of doing multiple computations for multiple points&lt;/p>
&lt;h3 id="types-of-transformation">Types of transformation&lt;/h3>
&lt;p>$$T(x,y,z) = Translation$$
$$S(x,y,z) = Scaling$$
$$Rx(theta) = \text{Rotation over x-axis}$$
$$Ry(theta) = \text{Rotation over y-axis}$$
$$Rz(theta) = \text{Rotation over z-axis}$$&lt;/p>
&lt;h3 id="example-of-transformation">Example of transformation&lt;/h3>
&lt;p>Let&amp;rsquo;s say we want to rotate an object ϴ on a 2D plane with a point P as it&amp;rsquo;s rotation pivot:&lt;/p>
&lt;ol>
&lt;li>You want to first translate the object to have point P of the object be at the origin (anything at the origin will not be affected during scaling, translation, or rotation)
&lt;ol>
&lt;li>$$T(-p.x,-p.y,-p.z) = P $$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Next you want to do a rotation around the z-axis (since we are in 2D)
&lt;ol>
&lt;li>$$Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Finally you want to move the object back to its original position
&lt;ol>
&lt;li>$$T(p.x, p.y, p.z) * Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>Note: Matrix operations go right to left, you need to order the matricies in the order of the transformations correctly&lt;/em>&lt;/p>
&lt;h2 id="hierachical-models">Hierachical Models&lt;/h2>
&lt;p>With most models, we want certain objects to move similar to joints, where they move if a parent object moves. This is a form called &lt;strong>Hierachical modeling&lt;/strong>&lt;/p>
&lt;p>You can view it like this:&lt;/p>
&lt;ul>
&lt;li>World
&lt;ul>
&lt;li>Body
&lt;ul>
&lt;li>Arms
&lt;ul>
&lt;li>Hands
&lt;ul>
&lt;li>Fingers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Head
&lt;ul>
&lt;li>Ears&lt;/li>
&lt;li>Eyes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>You can view this as a tree of different matrix transformations&lt;/p>
&lt;h3 id="coordinate-frames">Coordinate Frames&lt;/h3>
&lt;p>You can imagine a coordinate frame as a screenshot of the coordinate system/unit vectors transposed and rotated in some fashion.&lt;/p>
&lt;p>In a hierachical system, each parent-child relationship comes with a coordinate frame that dictates the world view of the particular object&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png"
width="332"
height="504"
srcset="/p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="frames"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="158px"
>&lt;/p>
&lt;p>In a hiearchy, a coordinate frame is made up from the previous coordinate frames from the parents above.&lt;/p>
&lt;p>In the above example:
$$C_0 = T_0$$
$$C_1 = T_1 * R_{x_1}(\theta) * C_0$$
$$C_2 = T_2 * R_{x_2}(\theta) * C_1$$&lt;/p>
&lt;p>Each object uses their own coordinate frame to determine the position of their pixels&lt;/p>
&lt;p>$$\text{Blue} = C_0 * T * S$$
$$\text{Red} = C_1 * T * S$$
$$\text{Green} = C_2 * T * S$$&lt;/p>
&lt;p>With these, if a parents moves in someway, the children will also be affected by them.&lt;/p>
&lt;p>Another way to view the relationships is like this:
&lt;img src="/p/3d-graphics-hierarchy-models/hierarchyTree.png"
width="658"
height="766"
srcset="/p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="hierarchyTree"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="206px"
>&lt;/p>
&lt;p>Now to actually do the math to create these objects, you need to create the overaching matricies multipled with the points of the object.&lt;/p>
&lt;h3 id="generating-the-hierachical-matrix">Generating the hierachical matrix&lt;/h3>
&lt;p>You can view this process as a in-order traversal/DFS using a stack. The stack represents the current overall matrix while you push and pop mini transformation components.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We start with generating the blue block by adding the first coordinate frame into the stack and then adding the block&amp;rsquo;s independent transformations into the stack.
&lt;img src="/p/3d-graphics-hierarchy-models/step1.png"
width="928"
height="848"
srcset="/p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step1"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="262px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then remove the independent transformations of the blue block and add in the additional transformations that make up our next coordinate frame. We then add in the independent transforations of the red block
&lt;img src="/p/3d-graphics-hierarchy-models/step2.png"
width="940"
height="866"
srcset="/p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step2"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then perform the same steps, remove independent transformations -&amp;gt; create next coordinate frame, add in new independent transformations&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/finalStep.png"
width="804"
height="744"
srcset="/p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step3"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p></description></item><item><title>3D Graphics Intro</title><link>/p/3d-graphics-intro/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-intro/</guid><description>&lt;img src="https://cdn5.vectorstock.com/i/1000x1000/47/14/3d-coordinate-axis-vector-7814714.jpg" alt="Featured image of post 3D Graphics Intro" />&lt;h1 id="overview--affine-transformation">Overview &amp;amp; Affine Transformation&lt;/h1>
&lt;h2 id="3d-rotation">3D Rotation&lt;/h2>
&lt;ul>
&lt;li>Cos(theta) in the matrix scaling spots&lt;/li>
&lt;li>Sin(theta) and -Sin(theta) in the matrix sheering spots&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) \\
Sin(ϴ) &amp;amp; Cos(ϴ)
\end{bmatrix}
$$&lt;/p>
&lt;p>&lt;strong>3D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) &amp;amp; 0 \\
Sin(ϴ) &amp;amp; Cos(ϴ) &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;h2 id="homogeneous-coordinates">Homogeneous Coordinates&lt;/h2>
&lt;p>Have an extra collumn in the transformation matrix to represent translation&lt;/p>
&lt;p>&lt;strong>2D Translation&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Move to a 3D dimension and make the third collumn in the matrix a translation vector&lt;/li>
&lt;/ul>
&lt;p>$$
\begin{bmatrix}
x+1 \\
y \\
0
\end{bmatrix}=
\begin{bmatrix}
x+1\\
y
\end{bmatrix}=
\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
*
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$&lt;/p></description></item></channel></rss>