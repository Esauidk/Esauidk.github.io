<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Esau's Page</title><link>/categories/math/</link><description>Recent content in Math on Esau's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 22 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/math/index.xml" rel="self" type="application/rss+xml"/><item><title>3D Graphics: Camera Projection</title><link>/p/3d-graphics-camera-projection/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-camera-projection/</guid><description>&lt;img src="/p/3d-graphics-camera-projection/titleImage.jpeg" alt="Featured image of post 3D Graphics: Camera Projection" />&lt;p>Images project onto a surface/plane through light rays reflecting on the object. We view light that has reflected onto a point of the object and landed on a point of the plane.&lt;/p>
&lt;h2 id="aperture">Aperture&lt;/h2>
&lt;p>If we just tried to view the rays of light normally, we wouldn&amp;rsquo;t be able to see anything due to how the multiple rays of the object landing in the same spot, creating some blurry/non recognizable image of the object&lt;/p>
&lt;p>Appetures are a way of focusing the rays of light from the objects into particular points.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/apeture.png"
width="360"
height="340"
srcset="/p/3d-graphics-camera-projection/apeture_hu735361f69c883abf3d39687f43a92dc3_41978_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/apeture_hu735361f69c883abf3d39687f43a92dc3_41978_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ApetureImage"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="254px"
>&lt;/p>
&lt;h3 id="how-they-work">How they work&lt;/h3>
&lt;p>Apertures are holes that alllow and block rays of light to reach the canvas/image plane. This allows us to control which and how many rays of light can reach the canvas. Normally focus lens are added on top to ensure that the rays of light that enter focus to a point.&lt;/p>
&lt;h2 id="projections">Projections&lt;/h2>
&lt;p>There are two types of projections:
&lt;strong>Perspective&lt;/strong>: A projection from a point on the image plane to the center of projection (camera/ or eye)
&lt;strong>Parallel&lt;/strong>: A projection from a point on the image plane in a direction perpendicular to the image surface&lt;/p>
&lt;h3 id="perspective-projection">Perspective Projection&lt;/h3>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/perspective.png"
width="920"
height="420"
srcset="/p/3d-graphics-camera-projection/perspective_hu68219beb93dbb33931fa45330fdd1758_46331_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/perspective_hu68219beb93dbb33931fa45330fdd1758_46331_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="perspective"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="525px"
>&lt;/p>
&lt;p>The goal is to project your point (in this case (X,Y,Z)) onto the image plane. We see that as we move towards the center of project (P) the point (X,Y,Z) gets scaled down in all dimensions.&lt;/p>
&lt;p>The distance of the point to the center of projection is represented by the Z-coordinate since we consider the center of projection to always be (0, 0, 0). Now if we projected the points onto an image plane at the center of projection, all of our points would be at (0, 0, 0).&lt;/p>
&lt;p>This is where the focal length $f$ come in. This represents the distance from the center of projection to the image plane, so instead of the points being projected at Z = 0, they are projected at Z = f&lt;/p>
&lt;p>With that we want to scale down the point&amp;rsquo;s Z position to be the focal length position&lt;/p>
&lt;p>$$ \begin{bmatrix} x \\ y \\ f \end{bmatrix} = \frac{f}{Z} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix} = \begin{bmatrix} X * \frac{f}{Z} \\ Y * \frac{f}{Z} \\ Z * \frac{f}{Z} \end{bmatrix} $$&lt;/p>
&lt;p>This then generates the now projected version of our original point for the specific image plane&lt;/p>
&lt;h3 id="parallel-projection">Parallel Projection&lt;/h3>
&lt;p>There is no scaling done to primitives when doing parallel projection. Instead of projecting to a center of projection like with perspective, you project parallel to the image plane&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/parallel.png"
width="1984"
height="1164"
srcset="/p/3d-graphics-camera-projection/parallel_hu0d0ee340b0fcd0a8536d175548934945_87339_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/parallel_hu0d0ee340b0fcd0a8536d175548934945_87339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="parallel"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p></description></item><item><title>3D Graphics: Light Reflection Models</title><link>/p/3d-graphics-light-reflection-models/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-light-reflection-models/</guid><description>&lt;img src="https://academyofanimatedart.com/wp-content/uploads/2019/03/td-u-CG-lighting-shadows-light-shading-featured.jpg" alt="Featured image of post 3D Graphics: Light Reflection Models" />&lt;p>Naturally photons/light bounces on impact with surfaces, but how does it bouce off?&lt;/p>
&lt;h1 id="mirrorslight-models">Mirrors/Light Models&lt;/h1>
&lt;p>Mirros are the best example of how light reflects, when something is viewed through a mirror it is flipped along the z-axis&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/light.png"
width="500"
height="294"
srcset="/p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Light"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>In terms on how to calculate the light reflected to a view, there are many different types of light reflection models&lt;/p>
&lt;h3 id="variables">Variables&lt;/h3>
&lt;p>$I_V =$ Light intesity for viewer&lt;/p>
&lt;p>$I_L =$ Light intensity from source&lt;/p>
&lt;p>$V =$ Viewing vector&lt;/p>
&lt;p>$R =$ Reflection vector&lt;/p>
&lt;p>$N =$ Normal Vector&lt;/p>
&lt;h2 id="phong-reflection-specular">Phong Reflection (Specular)&lt;/h2>
&lt;p>This uses the reflection of the light vector and the angle between the reflection and the veiwing vector to determine the intensity of light that the camera/viewer sees&lt;/p>
&lt;p>$I_V = I_L * (V \cdot R)^a$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/phong.png"
width="800"
height="282"
srcset="/p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="phong"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="680px"
>&lt;/p>
&lt;h2 id="blinn-phong-specular">Blinn-Phong (Specular)&lt;/h2>
&lt;p>Instead of using the angle between the reflection and viewer, Blinn-Phong uses the angle between the half vector of the light vector and view vector ($H = L + V$)
$I_V = I_L * (N \cdot H)^a$
&lt;img src="/p/3d-graphics-light-reflection-models/blinn-phong.png"
width="600"
height="402"
srcset="/p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bphong"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;h2 id="lambertian-reflectiondiffuse">Lambertian Reflection(Diffuse)&lt;/h2>
&lt;p>This type of reflection represents when light equally gets spread in all directions in oppose to the other light models that represent when light gets spread unevenly depending on the viewing angle&lt;/p>
&lt;p>$I_O = I_L * N \cdot L$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/diffuse.png"
width="594"
height="244"
srcset="/p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="diffuse"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;h2 id="ambient-light">Ambient Light&lt;/h2>
&lt;p>Ambient light is the light that exists after infinite amounts of reflections. You can view it as the &amp;ldquo;light in the room&amp;rdquo;. Since it is a result from infinite amounts of reflections, it is normally treated as a predefined constant&lt;/p>
&lt;h1 id="diffuse--specular">Diffuse &amp;amp; Specular&lt;/h1>
&lt;p>To make it clear, diffuse light models focus on when light on impact spreads evenly in all directions while specular focuses on when light is spread more intense in certain directions.&lt;/p>
&lt;p>This is not a 1 or the other phenomenon. These light models(specular &amp;amp; diffuse) both happen at the same time in real life. For example an apple refuses to absorb the color red and spreads it out evenly in all directions, but the layer of wax around it just reflects the light specularly. We have both specular light and diffuse light happening at the same time!&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/apple.png"
width="1090"
height="802"
srcset="/p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="apple"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="326px"
>&lt;/p>
&lt;h1 id="light-model">Light Model&lt;/h1>
&lt;p>Since we know that light is the combination of ambient, specular, and diffuse lighting, we can view the equation for light to be like this:&lt;/p>
&lt;p>$I = I_{La} + I_L * (N \cdot H)^a + I_L * (N \cdot L)$
$I_{La}$ = Ambient light Inensity&lt;/p>
&lt;p>Light is additive, meaning multiple lights just get added together&lt;/p>
&lt;p>$I = I_{La} + \sum_{j} I_{L_{j}} * (N \cdot H_{j})^a + {I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$&lt;/p>
&lt;p>There are also specific scalers that define the properities of the object used in the light model
$k_d=$ diffusal color
$k_s=$ specular color
a = specular shininess&lt;/p>
&lt;p>$I = I_{La} + \sum_{j} k_s * I_{L_{j}} * (N \cdot H_{j})^a + k_d *{I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$&lt;/p>
&lt;h2 id="attenuation">Attenuation&lt;/h2>
&lt;p>To add on to the light model, light follows a pheonomenon known as the &lt;em>Inverse Square Rule&lt;/em>. This rule is as light spreads farther out from the source, the intesnity of it decreases inversly of the square distance&lt;/p>
&lt;p>$I_L = \frac{I_{s}}{4 * \pi * r^2}$&lt;/p>
&lt;p>$s=$ source
$r$ = radius from source&lt;/p>
&lt;p>Attenuation is a variation of the inverse square rule that lets us define an approximation of the intensity decay&lt;/p>
&lt;p>$I_L = \frac{I_{s}}{ar^2+br + c}$
$a$, $b$, $c$ are constants that can be changed to fit the right intensity decay model desired&lt;/p></description></item><item><title>3D Graphics: Meshing</title><link>/p/3d-graphics-meshing/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-meshing/</guid><description>&lt;img src="https://i.stack.imgur.com/Bk826.png" alt="Featured image of post 3D Graphics: Meshing" />&lt;p>A mesh is a collection of primitives shape that make up an overarching model
&lt;img src="/p/3d-graphics-meshing/mesh.png"
width="1000"
height="1080"
srcset="/p/3d-graphics-meshing/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Mesh"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="222px"
>&lt;/p>
&lt;h2 id="storing-mesh-data">Storing Mesh Data&lt;/h2>
&lt;h3 id="storing-mesh">Storing Mesh&lt;/h3>
&lt;p>To efficiently store mesh data, we want to reduce the amount of redundancy when rendering the primitive shapes.&lt;/p>
&lt;p>We do this by storing all the verticies of involved in the mesh and storing all the different combination of the verticies that make up our primitive shape&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0 \\
V_1 \\
V_2 \\
&amp;hellip; \\
V_n
\end{bmatrix}
$$&lt;/p>
&lt;p>Primitive Shape Data
$$
\begin{bmatrix}
0,1,2 \\
3,4,5 \\
&amp;hellip; \\
n-2, n-1, n
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="vertex-order-matters">Vertex Order Matters&lt;/h3>
&lt;p>In practice, the order of the verticies of a mesh is used to determine the &lt;strong>normal&lt;/strong> (an indication of which side of the primitive is the front and back). Putting the verticies in the wrong order can get results that are unexpected&lt;/p>
&lt;h3 id="culling">Culling&lt;/h3>
&lt;p>Culling is a technique used to reduce the amount of primitve shapes being rendered by the render engine. It expects to render only one side of the primitve shape, the front side! (Unless specified that it&amp;rsquo;s double sided).&lt;/p>
&lt;p>Determining the side of the primitve is done through vector math!&lt;/p>
&lt;p>&lt;strong>Calculating the angle:&lt;/strong>&lt;/p>
&lt;p>Cos(ϴ) = -V * N&lt;/p>
&lt;p>V = viewing vector (from the camera to the object)&lt;/p>
&lt;p>N = normal vector&lt;/p>
&lt;p>ϴ &amp;gt; 0 = front facing
ϴ &amp;lt;= 0 = back facing&lt;/p>
&lt;p>Having the wrong normals can cause a triangle to not be rendered&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/wrongIndex.png"
width="450"
height="193"
srcset="/p/3d-graphics-meshing/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="indexDif"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="559px"
>&lt;/p>
&lt;h3 id="storing-normals">Storing Normals&lt;/h3>
&lt;p>Normals could be calculated per triangle using some math, but that would introduce problems when wanting to create smooth surfraces of multiple primitives.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/interpResult.png"
width="670"
height="355"
srcset="/p/3d-graphics-meshing/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="interpResult"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="452px"
>&lt;/p>
&lt;p>To avoid this issue, we give every &lt;strong>vertex&lt;/strong> a normal vector and interpolate normal vectors intermediate points on the primitive&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/normalInterpolation.png"
width="670"
height="247"
srcset="/p/3d-graphics-meshing/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="normalInterp"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="651px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0, N_0 \\
V_1, N_1 \\
V_2, N_2 \\
&amp;hellip; \\
V_n, N_n
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="storing-textures">Storing Textures&lt;/h3>
&lt;p>We have an object with a correct shape, but what if we want to paint it with an image? This is done through the power of UV mapping.&lt;/p>
&lt;p>UV mapping is the process of assign a pixel on the texture/image with a pixel on the model. We assign a vertex on our mesh with a 2D coordinate corresponding a pixel on the texture. Other UV positions on the non-vertex mesh pixels are interpolated.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/UVMapping.png"
width="640"
height="336"
srcset="/p/3d-graphics-meshing/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UVMapping"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="457px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0, N_0, (U,V)_0 \\
V_1, N_1, (U,V)_1 \\
V_2, N_2, (U,V)_2 \\
&amp;hellip; \\
V_n, N_n, (U,V)_n
\end{bmatrix}
$$&lt;/p></description></item><item><title>3D Graphics: Hierarchy Models</title><link>/p/3d-graphics-hierarchy-models/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-hierarchy-models/</guid><description>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png" alt="Featured image of post 3D Graphics: Hierarchy Models" />&lt;h2 id="matrix-transformation">Matrix Transformation&lt;/h2>
&lt;p>The reason we keep things like translations as a matrix transformation instead of a simple collumn addition is for &lt;strong>EFFICIENCY&lt;/strong>.&lt;/p>
&lt;p>If we wanted to do multiple transformations on an objects.&lt;/p>
&lt;p>$$(M_N * &amp;hellip; * M_1) * P $$&lt;/p>
&lt;p>is easier than&lt;/p>
&lt;p>$$(M_2 * ((M_1 * P ) + T_1) + T_2)$$&lt;/p>
&lt;p>We can calculate the overall matrix onces instead of doing multiple computations for multiple points&lt;/p>
&lt;h3 id="types-of-transformation">Types of transformation&lt;/h3>
&lt;p>$$T(x,y,z) = Translation$$
$$S(x,y,z) = Scaling$$
$$Rx(theta) = \text{Rotation over x-axis}$$
$$Ry(theta) = \text{Rotation over y-axis}$$
$$Rz(theta) = \text{Rotation over z-axis}$$&lt;/p>
&lt;h3 id="example-of-transformation">Example of transformation&lt;/h3>
&lt;p>Let&amp;rsquo;s say we want to rotate an object ϴ on a 2D plane with a point P as it&amp;rsquo;s rotation pivot:&lt;/p>
&lt;ol>
&lt;li>You want to first translate the object to have point P of the object be at the origin (anything at the origin will not be affected during scaling, translation, or rotation)
&lt;ol>
&lt;li>$$T(-p.x,-p.y,-p.z) = P $$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Next you want to do a rotation around the z-axis (since we are in 2D)
&lt;ol>
&lt;li>$$Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Finally you want to move the object back to its original position
&lt;ol>
&lt;li>$$T(p.x, p.y, p.z) * Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>Note: Matrix operations go right to left, you need to order the matricies in the order of the transformations correctly&lt;/em>&lt;/p>
&lt;h2 id="hierachical-models">Hierachical Models&lt;/h2>
&lt;p>With most models, we want certain objects to move similar to joints, where they move if a parent object moves. This is a form called &lt;strong>Hierachical modeling&lt;/strong>&lt;/p>
&lt;p>You can view it like this:&lt;/p>
&lt;ul>
&lt;li>World
&lt;ul>
&lt;li>Body
&lt;ul>
&lt;li>Arms
&lt;ul>
&lt;li>Hands
&lt;ul>
&lt;li>Fingers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Head
&lt;ul>
&lt;li>Ears&lt;/li>
&lt;li>Eyes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>You can view this as a tree of different matrix transformations&lt;/p>
&lt;h3 id="coordinate-frames">Coordinate Frames&lt;/h3>
&lt;p>You can imagine a coordinate frame as a screenshot of the coordinate system/unit vectors transposed and rotated in some fashion.&lt;/p>
&lt;p>In a hierachical system, each parent-child relationship comes with a coordinate frame that dictates the world view of the particular object&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png"
width="332"
height="504"
srcset="/p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="frames"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="158px"
>&lt;/p>
&lt;p>In a hiearchy, a coordinate frame is made up from the previous coordinate frames from the parents above.&lt;/p>
&lt;p>In the above example:
$$C_0 = T_0$$
$$C_1 = T_1 * R_{x_1}(\theta) * C_0$$
$$C_2 = T_2 * R_{x_2}(\theta) * C_1$$&lt;/p>
&lt;p>Each object uses their own coordinate frame to determine the position of their pixels&lt;/p>
&lt;p>$$\text{Blue} = C_0 * T * S$$
$$\text{Red} = C_1 * T * S$$
$$\text{Green} = C_2 * T * S$$&lt;/p>
&lt;p>With these, if a parents moves in someway, the children will also be affected by them.&lt;/p>
&lt;p>Another way to view the relationships is like this:
&lt;img src="/p/3d-graphics-hierarchy-models/hierarchyTree.png"
width="658"
height="766"
srcset="/p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="hierarchyTree"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="206px"
>&lt;/p>
&lt;p>Now to actually do the math to create these objects, you need to create the overaching matricies multipled with the points of the object.&lt;/p>
&lt;h3 id="generating-the-hierachical-matrix">Generating the hierachical matrix&lt;/h3>
&lt;p>You can view this process as a in-order traversal/DFS using a stack. The stack represents the current overall matrix while you push and pop mini transformation components.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We start with generating the blue block by adding the first coordinate frame into the stack and then adding the block&amp;rsquo;s independent transformations into the stack.
&lt;img src="/p/3d-graphics-hierarchy-models/step1.png"
width="928"
height="848"
srcset="/p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step1"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="262px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then remove the independent transformations of the blue block and add in the additional transformations that make up our next coordinate frame. We then add in the independent transforations of the red block
&lt;img src="/p/3d-graphics-hierarchy-models/step2.png"
width="940"
height="866"
srcset="/p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step2"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then perform the same steps, remove independent transformations -&amp;gt; create next coordinate frame, add in new independent transformations&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/finalStep.png"
width="804"
height="744"
srcset="/p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step3"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p></description></item><item><title>3D Graphics Intro</title><link>/p/3d-graphics-intro/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-intro/</guid><description>&lt;img src="https://cdn5.vectorstock.com/i/1000x1000/47/14/3d-coordinate-axis-vector-7814714.jpg" alt="Featured image of post 3D Graphics Intro" />&lt;h1 id="overview--affine-transformation">Overview &amp;amp; Affine Transformation&lt;/h1>
&lt;h2 id="3d-rotation">3D Rotation&lt;/h2>
&lt;ul>
&lt;li>Cos(theta) in the matrix scaling spots&lt;/li>
&lt;li>Sin(theta) and -Sin(theta) in the matrix sheering spots&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) \\
Sin(ϴ) &amp;amp; Cos(ϴ)
\end{bmatrix}
$$&lt;/p>
&lt;p>&lt;strong>3D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) &amp;amp; 0 \\
Sin(ϴ) &amp;amp; Cos(ϴ) &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;h2 id="homogeneous-coordinates">Homogeneous Coordinates&lt;/h2>
&lt;p>Have an extra collumn in the transformation matrix to represent translation&lt;/p>
&lt;p>&lt;strong>2D Translation&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Move to a 3D dimension and make the third collumn in the matrix a translation vector&lt;/li>
&lt;/ul>
&lt;p>$$
\begin{bmatrix}
x+1 \\
y \\
0
\end{bmatrix}=
\begin{bmatrix}
x+1\\
y
\end{bmatrix}=
\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
*
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$&lt;/p></description></item></channel></rss>