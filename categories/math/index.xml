<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Math on Esau's Page</title><link>/categories/math/</link><description>Recent content in Math on Esau's Page</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 22 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/math/index.xml" rel="self" type="application/rss+xml"/><item><title>3D Graphics: Accelerated RayTracing</title><link>/p/3d-graphics-accelerated-raytracing/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-accelerated-raytracing/</guid><description>&lt;img src="https://blogs.nvidia.com/wp-content/uploads/2019/06/rtx-on-off.png" alt="Featured image of post 3D Graphics: Accelerated RayTracing" />&lt;p>Tatics that enhanced and accelerated raytracing&lt;/p>
&lt;h1 id="anti-aliasing">Anti-Aliasing&lt;/h1>
&lt;p>Aliasing is when the change between pixels is too sudden to be realistic to the image, creating a unrealistic image. In raytracing this can happen when not enough rays are sampled for a pixel.
&lt;img src="/p/3d-graphics-accelerated-raytracing/alias.png"
width="437"
height="274"
srcset="/p/3d-graphics-accelerated-raytracing/alias_hu7c5a63f5e63e1fd56eb0181a28fc044b_18970_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/alias_hu7c5a63f5e63e1fd56eb0181a28fc044b_18970_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="alias"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="382px"
>&lt;/p>
&lt;h2 id="super-sampling">Super Sampling&lt;/h2>
&lt;p>Aliasing occurs when the sampling (i.e. shooting rays) is down too far apart, leading to certain areas of a pixel which could have a different value not being sampled&lt;/p>
&lt;h3 id="adaptive-sampling">Adaptive Sampling&lt;/h3>
&lt;p>The basic idea of adaptive sampling is to add more sample points (rays) in areas that show indications of inbetween values not being sampled&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-accelerated-raytracing/supersample.png"
width="704"
height="606"
srcset="/p/3d-graphics-accelerated-raytracing/supersample_hudcbb9222eee54f0c640f69286926d800_95137_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/supersample_hudcbb9222eee54f0c640f69286926d800_95137_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="supersampling"
class="gallery-image"
data-flex-grow="116"
data-flex-basis="278px"
>&lt;/p>
&lt;h3 id="distribution-raycasting">Distribution Raycasting&lt;/h3>
&lt;p>Instead of adding more rays to get the correct sample, we can use a distribution (specifically the poisson distribution) to determine the best place on the pixel to sample our ray&lt;/p>
&lt;h1 id="acceleration">Acceleration&lt;/h1>
&lt;h2 id="ray-polyhedron-intersection">Ray-Polyhedron Intersection&lt;/h2>
&lt;p>There are many ways to handle intersection with triangle based objects&lt;/p>
&lt;h3 id="bounding-volume">Bounding Volume&lt;/h3>
&lt;p>You can using a bounding volume to determine if you are touching an object. This allows you to use primitives to determine intersection while costing accuracy&lt;/p>
&lt;h4 id="bounding-voluming-hierarchy">Bounding Voluming Hierarchy&lt;/h4>
&lt;p>Instead of &lt;strong>only&lt;/strong> giving the overall object a bounding volume, you can do a hierarichal tree of boudning volumes that also seperate pieces of the objects in volumes&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-accelerated-raytracing/dragon.png"
width="1280"
height="720"
srcset="/p/3d-graphics-accelerated-raytracing/dragon_hubbe6c356053ad4498b86e7fb8a0d2339_708993_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/dragon_hubbe6c356053ad4498b86e7fb8a0d2339_708993_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="dragon"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-accelerated-raytracing/bounding.png"
width="1000"
height="313"
srcset="/p/3d-graphics-accelerated-raytracing/bounding_huded67bc138525de7a7451f6725a804d7_46049_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/bounding_huded67bc138525de7a7451f6725a804d7_46049_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bounding"
class="gallery-image"
data-flex-grow="319"
data-flex-basis="766px"
>&lt;/p>
&lt;h3 id="spatial-subdivision">Spatial Subdivision&lt;/h3>
&lt;h5 id="uniform">Uniform&lt;/h5>
&lt;p>The idea of spatial subdivision is to divide the world space into cells uniformally and tying objects to the cells it overlaps
&lt;img src="/p/3d-graphics-accelerated-raytracing/uniformDivision.png"
width="1390"
height="642"
srcset="/p/3d-graphics-accelerated-raytracing/uniformDivision_hu630c555f0592f9057c4a6f4706e1796f_243742_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/uniformDivision_hu630c555f0592f9057c4a6f4706e1796f_243742_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="uniformSpace"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="519px"
>&lt;/p>
&lt;h5 id="non-uniform">Non-Uniform&lt;/h5>
&lt;p>As the name suggests, it&amp;rsquo;s the same idea of the uniform method but with the cells being non-uniformally subdivided
&lt;img src="/p/3d-graphics-accelerated-raytracing/nonUniformDivision.png"
width="1436"
height="630"
srcset="/p/3d-graphics-accelerated-raytracing/nonUniformDivision_hu272fdaceef125a4de6fe95eb172004a4_213158_480x0_resize_box_3.png 480w, /p/3d-graphics-accelerated-raytracing/nonUniformDivision_hu272fdaceef125a4de6fe95eb172004a4_213158_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="nonUniformSpace"
class="gallery-image"
data-flex-grow="227"
data-flex-basis="547px"
>&lt;/p></description></item><item><title>3D Graphics: Camera Projection</title><link>/p/3d-graphics-camera-projection/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-camera-projection/</guid><description>&lt;img src="/p/3d-graphics-camera-projection/titleImage.jpeg" alt="Featured image of post 3D Graphics: Camera Projection" />&lt;p>Images project onto a surface/plane through light rays reflecting on the object. We view light that has reflected onto a point of the object and landed on a point of the plane.&lt;/p>
&lt;h2 id="aperture">Aperture&lt;/h2>
&lt;p>If we just tried to view the rays of light normally, we wouldn&amp;rsquo;t be able to see anything due to how the multiple rays of the object landing in the same spot, creating some blurry/non recognizable image of the object&lt;/p>
&lt;p>Appetures are a way of focusing the rays of light from the objects into particular points.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/apeture.png"
width="360"
height="340"
srcset="/p/3d-graphics-camera-projection/apeture_hu735361f69c883abf3d39687f43a92dc3_41978_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/apeture_hu735361f69c883abf3d39687f43a92dc3_41978_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="ApetureImage"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="254px"
>&lt;/p>
&lt;h3 id="how-they-work">How they work&lt;/h3>
&lt;p>Apertures are holes that alllow and block rays of light to reach the canvas/image plane. This allows us to control which and how many rays of light can reach the canvas. Normally focus lens are added on top to ensure that the rays of light that enter focus to a point.&lt;/p>
&lt;h2 id="projections">Projections&lt;/h2>
&lt;p>There are two types of projections:
&lt;strong>Perspective&lt;/strong>: A projection from a point on the image plane to the center of projection (camera/ or eye)
&lt;strong>Parallel&lt;/strong>: A projection from a point on the image plane in a direction perpendicular to the image surface&lt;/p>
&lt;h3 id="perspective-projection">Perspective Projection&lt;/h3>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/perspective.png"
width="920"
height="420"
srcset="/p/3d-graphics-camera-projection/perspective_hu68219beb93dbb33931fa45330fdd1758_46331_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/perspective_hu68219beb93dbb33931fa45330fdd1758_46331_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="perspective"
class="gallery-image"
data-flex-grow="219"
data-flex-basis="525px"
>&lt;/p>
&lt;p>The goal is to project your point (in this case (X,Y,Z)) onto the image plane. We see that as we move towards the center of project (P) the point (X,Y,Z) gets scaled down in all dimensions.&lt;/p>
&lt;p>The distance of the point to the center of projection is represented by the Z-coordinate since we consider the center of projection to always be (0, 0, 0). Now if we projected the points onto an image plane at the center of projection, all of our points would be at (0, 0, 0).&lt;/p>
&lt;p>This is where the focal length $f$ come in. This represents the distance from the center of projection to the image plane, so instead of the points being projected at Z = 0, they are projected at Z = f&lt;/p>
&lt;p>With that we want to scale down the point&amp;rsquo;s Z position to be the focal length position&lt;/p>
&lt;p>$$ \begin{bmatrix} x \\ y \\ f \end{bmatrix} = \frac{f}{Z} \begin{bmatrix} X \\ Y \\ Z \end{bmatrix} = \begin{bmatrix} X * \frac{f}{Z} \\ Y * \frac{f}{Z} \\ Z * \frac{f}{Z} \end{bmatrix} $$&lt;/p>
&lt;p>This then generates the now projected version of our original point for the specific image plane&lt;/p>
&lt;h3 id="parallel-projection">Parallel Projection&lt;/h3>
&lt;p>There is no scaling done to primitives when doing parallel projection. Instead of projecting to a center of projection like with perspective, you project parallel to the image plane&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-camera-projection/parallel.png"
width="1984"
height="1164"
srcset="/p/3d-graphics-camera-projection/parallel_hu0d0ee340b0fcd0a8536d175548934945_87339_480x0_resize_box_3.png 480w, /p/3d-graphics-camera-projection/parallel_hu0d0ee340b0fcd0a8536d175548934945_87339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="parallel"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p></description></item><item><title>3D Graphics: Light Reflection Models</title><link>/p/3d-graphics-light-reflection-models/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-light-reflection-models/</guid><description>&lt;img src="https://academyofanimatedart.com/wp-content/uploads/2019/03/td-u-CG-lighting-shadows-light-shading-featured.jpg" alt="Featured image of post 3D Graphics: Light Reflection Models" />&lt;p>Naturally photons/light bounces on impact with surfaces, but how does it bouce off?&lt;/p>
&lt;h1 id="mirrorslight-models">Mirrors/Light Models&lt;/h1>
&lt;p>Mirros are the best example of how light reflects, when something is viewed through a mirror it is flipped along the z-axis&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/light.png"
width="500"
height="294"
srcset="/p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/light_hu77cad1afd0599f3bfa0c130fe311020d_32445_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Light"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>In terms on how to calculate the light reflected to a view, there are many different types of light reflection models&lt;/p>
&lt;h3 id="variables">Variables&lt;/h3>
&lt;p>$I_V =$ Light intesity for viewer&lt;/p>
&lt;p>$I_L =$ Light intensity from source&lt;/p>
&lt;p>$V =$ Viewing vector&lt;/p>
&lt;p>$R =$ Reflection vector&lt;/p>
&lt;p>$N =$ Normal Vector&lt;/p>
&lt;h2 id="phong-reflection-specular">Phong Reflection (Specular)&lt;/h2>
&lt;p>This uses the reflection of the light vector and the angle between the reflection and the veiwing vector to determine the intensity of light that the camera/viewer sees&lt;/p>
&lt;p>$$I_V = I_L * (V \cdot R)^a$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/phong.png"
width="800"
height="282"
srcset="/p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/phong_hu6c499441fd2015343ee2f918d0922bd6_39518_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="phong"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="680px"
>&lt;/p>
&lt;h2 id="blinn-phong-specular">Blinn-Phong (Specular)&lt;/h2>
&lt;p>Instead of using the angle between the reflection and viewer, Blinn-Phong uses the angle between the half vector of the light vector and view vector ($H = L + V$)&lt;/p>
&lt;p>$$I_V = I_L * (N \cdot H)^a$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/blinn-phong.png"
width="600"
height="402"
srcset="/p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/blinn-phong_hu2fff097b576fec7759b9e1a5917ffe36_24030_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bphong"
class="gallery-image"
data-flex-grow="149"
data-flex-basis="358px"
>&lt;/p>
&lt;h2 id="lambertian-reflectiondiffuse">Lambertian Reflection(Diffuse)&lt;/h2>
&lt;p>This type of reflection represents when light equally gets spread in all directions in oppose to the other light models that represent when light gets spread unevenly depending on the viewing angle&lt;/p>
&lt;p>$$I_O = I_L * N \cdot L$$&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/diffuse.png"
width="594"
height="244"
srcset="/p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/diffuse_hu9f5724614ce19765dc838a1d5ec4cae4_14546_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="diffuse"
class="gallery-image"
data-flex-grow="243"
data-flex-basis="584px"
>&lt;/p>
&lt;h2 id="ambient-light">Ambient Light&lt;/h2>
&lt;p>Ambient light is the light that exists after infinite amounts of reflections. You can view it as the &amp;ldquo;light in the room&amp;rdquo;. Since it is a result from infinite amounts of reflections, it is normally treated as a predefined constant&lt;/p>
&lt;h1 id="diffuse--specular">Diffuse &amp;amp; Specular&lt;/h1>
&lt;p>To make it clear, diffuse light models focus on when light on impact spreads evenly in all directions while specular focuses on when light is spread more intense in certain directions.&lt;/p>
&lt;p>This is not a 1 or the other phenomenon. These light models(specular &amp;amp; diffuse) both happen at the same time in real life. For example an apple refuses to absorb the color red and spreads it out evenly in all directions, but the layer of wax around it just reflects the light specularly. We have both specular light and diffuse light happening at the same time!&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-light-reflection-models/apple.png"
width="1090"
height="802"
srcset="/p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_480x0_resize_box_3.png 480w, /p/3d-graphics-light-reflection-models/apple_hu0b3dd9a1910c522dcc15faecc0d20109_673997_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="apple"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="326px"
>&lt;/p>
&lt;h1 id="light-model">Light Model&lt;/h1>
&lt;p>Since we know that light is the combination of ambient, specular, and diffuse lighting, we can view the equation for light to be like this:&lt;/p>
&lt;p>$$I = I_{La} + I_L * (N \cdot H)^a + I_L * (N \cdot L)$$
$I_{La}$ = Ambient light Inensity&lt;/p>
&lt;p>Light is additive, meaning multiple lights just get added together&lt;/p>
&lt;p>$$I = I_{La} + \sum_{j} I_{L_{j}} * (N \cdot H_{j})^a + {I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$$&lt;/p>
&lt;p>There are also specific scalers that define the properities of the object used in the light model
$k_d=$ diffusal color
$k_s=$ specular color
a = specular shininess&lt;/p>
&lt;p>$$I = I_{La} + \sum_{j} k_s * I_{L_{j}} * (N \cdot H_{j})^a + k_d *{I_L{&lt;em>j}} * (N \cdot L&lt;/em>{j})$$&lt;/p>
&lt;h2 id="attenuation">Attenuation&lt;/h2>
&lt;p>To add on to the light model, light follows a pheonomenon known as the &lt;em>Inverse Square Rule&lt;/em>. This rule is as light spreads farther out from the source, the intesnity of it decreases inversly of the square distance&lt;/p>
&lt;p>$$I_L = \frac{I_{s}}{4 * \pi * r^2}$$&lt;/p>
&lt;p>$s=$ source
$r$ = radius from source&lt;/p>
&lt;p>Attenuation is a variation of the inverse square rule that lets us define an approximation of the intensity decay&lt;/p>
&lt;p>$$I_L = \frac{I_{s}}{ar^2+br + c}$$
$a$, $b$, $c$ are constants that can be changed to fit the right intensity decay model desired&lt;/p></description></item><item><title>3D Graphics: RayTracing Intro</title><link>/p/3d-graphics-raytracing-intro/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-raytracing-intro/</guid><description>&lt;img src="https://i.ytimg.com/vi/Xs0WOuToefw/maxresdefault.jpg" alt="Featured image of post 3D Graphics: RayTracing Intro" />&lt;p>Raytracing is a form of light reflection calculation that allows shadows to be calculated and recieve more exact versions of light intensities&lt;/p>
&lt;h2 id="basic-raytracing">Basic Raytracing&lt;/h2>
&lt;p>We care about the rays of light that the sun emits and bounce around before hitting our eye. The sun emits millions of rays of light that never hit our eye so if we calculated all the rays of the sun, we would be wasting many computing cycles&lt;/p>
&lt;p>What is actually done in basic raytracing is to actually emit from the target (our vew/camera) and see which ray actually reaches the sun. We can set a limit on the number of reflections until we want to drop a ray and this let&amp;rsquo;s us calculate only the rays we care about&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-raytracing-intro/trace.png"
width="450"
height="383"
srcset="/p/3d-graphics-raytracing-intro/trace_hu031b6403895bc5f288de39d80fcd787e_37881_480x0_resize_box_3.png 480w, /p/3d-graphics-raytracing-intro/trace_hu031b6403895bc5f288de39d80fcd787e_37881_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="trace"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="281px"
>&lt;/p>
&lt;h3 id="shadows">Shadows&lt;/h3>
&lt;p>In terms of shadows, there are two different types of shadows: hard shadow &amp;amp; soft shadow&lt;/p>
&lt;ul>
&lt;li>Hard Shadow: No light ever hits the particular spot&lt;/li>
&lt;li>Soft Shadow: Some light hits the spot but not all&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="/p/3d-graphics-raytracing-intro/shadows.png"
width="380"
height="488"
srcset="/p/3d-graphics-raytracing-intro/shadows_hubc4c066f187a9122b37857bfdbb88c62_16009_480x0_resize_box_3.png 480w, /p/3d-graphics-raytracing-intro/shadows_hubc4c066f187a9122b37857bfdbb88c62_16009_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="shadow"
class="gallery-image"
data-flex-grow="77"
data-flex-basis="186px"
>&lt;/p>
&lt;h3 id="raytracing-psuedocode">Raytracing PsuedoCode&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Calculating all the rays&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># find intersection&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">intersect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># using the halfway point to calculate the reflection&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># (a + b)/2 = c &amp;amp;&amp;amp; -(c * 2) + a = b&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">reflection&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">d&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">#calculate the rotation of the current ray for the internal boucing of the object (ie: Figure out refraction ray)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">internalRay&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SnellLaw&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Get light intensity (light model: Specular + Diffuse + Ambience )&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">shade&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># reflection ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">+&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">specularColor&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">reflection&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># refraction ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">+&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">trasnmissive&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">inernalRay&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># performing ray tracing on the image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">traceImage&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">pixel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">translateFromProjectionToWorld&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixel&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">direction&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">camera&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span> &lt;span class="n">mag&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixelWorld&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">camera&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">traceRay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pixel&lt;/span> &lt;span class="n">world&lt;/span> &lt;span class="n">positiion&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># finding the intersection of a ray&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">intersect&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">point&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">distance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">z&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">point&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">Example&lt;/span> &lt;span class="k">with&lt;/span> &lt;span class="n">sphere&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">object&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">radius&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">z&lt;/span>&lt;span class="o">^&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">INTERSECTION&lt;/span> &lt;span class="n">CONFIRMED&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span> &lt;span class="n">shade&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">direction&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Grab the color of the object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">material&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">diffuseColor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Go for every light hitting this object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">each&lt;/span> &lt;span class="n">scene&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lights&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># calculate the attenuation of this point (both by distance and shadow)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">attenuation&lt;/span> &lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">distanceAtten&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">shadowAtten&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># get the direcetion of the light to the point&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">L&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">getDirection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">intersectionPoint&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Do diffusion, specular, and ambient lighting&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">intensity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">intensity&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">light&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ambient&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">attenuation&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">diffuse&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">specular&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">normal&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Return the final light intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">intensity&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="detecting-intersection">Detecting Intersection&lt;/h3>
&lt;p>A current point on a ray can be represented using the function
$$R(t) = P_0 + t\vec{d}$$
This is a function that will produce a point for us that we can immediately use to verify for intersection. Now we need a primitive to verify against. A simple example is using a sphere!&lt;/p>
&lt;h4 id="sphere">Sphere&lt;/h4>
&lt;p>We can represent a sphere using the equation:
$$x^2+y^2+z^2=r^2$$
This equation does two things, tells us the radius if we know a point on the sphere, but it also tells us whether something is on the same sphere if we only know the radius and need to confirm the points&lt;/p>
&lt;p>Using both equations, we can rewrite it into a solving for zero problem:&lt;/p>
&lt;p>$$x^2+y^2+z^2-r^2=0$$
Since we can produce the x,y, and z with our ray problem, we can turn it into a problem involving only one unknown variable, t!
$$(P_0x + t\vec{d_x})^2 + (P_0y + t\vec{d_y})^2 + (P_0z + t\vec{d_z})^2 - r^2 = 0 $$
Now before we call this good, we have to note, this equation will only tell us if a point lies exactly on the sphere. We want to also be able to tell if point is inside the sphere. We call solve this by turning this into an inequality&lt;/p>
&lt;p>$$(P_0x + t\vec{d_x})^2 + (P_0y + t\vec{d_y})^2 + (P_0z + t\vec{d_z})^2 - r^2 \leq 0 $$
&lt;strong>Disclaimer&lt;/strong>: This assumes the sphere starts at the origin (0,0,0), you will have to take that into account when using with a sphere not at the origin:
$$(x-a)^2+(y-b)^2+(z-c)^2=r^2$$
$a$,$b$,$c$ = sphere origin position&lt;/p>
&lt;h4 id="plane">Plane&lt;/h4>
&lt;p>Unlike spheres, we don&amp;rsquo;t have a nice clean equation to verify our points, we need to do vector maths&lt;/p>
&lt;p>We know that all points on a plane have the same normal, this means any vector we make using two points on the plane should be perpendicular to the normal!&lt;/p>
&lt;p>We can represent our verification fuction as:&lt;/p>
&lt;p>&lt;strong>with Q being the point generated from $R(t)$ and P being a point on the plane&lt;/strong>&lt;/p>
&lt;p>$$\vec{N} \cdot (Q - P)=0$$&lt;/p>
&lt;p>0 represents the normal and the vector derived with two points being perpendicular, anything else means it does not lie on the plane. &lt;strong>Note:&lt;/strong> Any point on the plane can be used to generate the $(Q-P)$ vector, as long as it&amp;rsquo;s normalized.&lt;/p></description></item><item><title>3D Graphics: Textures</title><link>/p/3d-graphics-textures/</link><pubDate>Sat, 22 Jul 2023 00:00:00 +0000</pubDate><guid>/p/3d-graphics-textures/</guid><description>&lt;img src="https://panespol.com/wp-content/uploads/2019/11/Textures_Panespol-1.jpg" alt="Featured image of post 3D Graphics: Textures" />&lt;p>How textures (images) are skinwrapped to meshes!&lt;/p>
&lt;h2 id="uv-mapping">UV Mapping&lt;/h2>
&lt;p>Maps coordates on a texture to the mesh using (U,V) coordinates&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/uv.png"
width="640"
height="336"
srcset="/p/3d-graphics-textures/uv_hud32cc52ffbba488d832b819481aef1c5_112050_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/uv_hud32cc52ffbba488d832b819481aef1c5_112050_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="uv"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="457px"
>&lt;/p>
&lt;h2 id="texture-resampling">Texture Resampling&lt;/h2>
&lt;p>There are times where you need to resample a texture after doing normal UV sampling, an example is when a texture sample lands in-between pixels in the texture. Resampling is a technique of resolving this issue.&lt;/p>
&lt;h3 id="bilinear-resampling">Bilinear Resampling&lt;/h3>
&lt;p>This is a form of resampling where the texture pixel color is calculated using the average of four corners of the pixel&lt;/p>
&lt;p>$$Pixel = A * P_D + B * P_C + C * P_B + D * P_A$$
$P_x =$ Precentage Area of pixel $x$
$A$,$B$,$C$,$D$ = Colors&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/bilinear.png"
width="310"
height="206"
srcset="/p/3d-graphics-textures/bilinear_huf12328e6d27924fd6925e78b2697122c_10573_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/bilinear_huf12328e6d27924fd6925e78b2697122c_10573_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bilinear"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="361px"
>&lt;/p>
&lt;h3 id="mip-map-resampling">Mip Map Resampling&lt;/h3>
&lt;p>Using binlinear by itself can be very costly (in a perspective project) as the object to be sampled on is farther and father away, there will be more instances of texture sampling resulting inbetween pixels.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/mipmap.png"
width="512"
height="275"
srcset="/p/3d-graphics-textures/mipmap_huc2042490259dade98a5ed7430e946a8f_27619_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/mipmap_huc2042490259dade98a5ed7430e946a8f_27619_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="mipmap"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="446px"
>&lt;/p>
&lt;p>Mip mapping is using prepocessed versions of the original texture (mip maps) for our resampling methods. As we get farther away from the image plane, the different mip maps we use for resampling. Normal interpolation is used between the two nearest mip maps. Lower quality textures are fine in this case because just like in real life we expect things to get blurry the farther they are.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/mipmappyramid.png"
width="264"
height="191"
srcset="/p/3d-graphics-textures/mipmappyramid_hu48b06e8ee80a1cd54daa5cf1281f941a_58818_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/mipmappyramid_hu48b06e8ee80a1cd54daa5cf1281f941a_58818_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="pyramid"
class="gallery-image"
data-flex-grow="138"
data-flex-basis="331px"
>&lt;/p>
&lt;h3 id="summed-area-tables">Summed area tables&lt;/h3>
&lt;p>Instead of using many tables (mip maps) to look up values on, we can also use the orignal image to derive the pixel&lt;/p>
&lt;p>Using area math, we can find the value of the area we want to use for the pixel&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/sumtable.png"
width="1548"
height="898"
srcset="/p/3d-graphics-textures/sumtable_hu80647031061b47306920e692111f7b61_337430_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/sumtable_hu80647031061b47306920e692111f7b61_337430_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="sumtable"
class="gallery-image"
data-flex-grow="172"
data-flex-basis="413px"
>&lt;/p>
&lt;h2 id="types-of-textures">Types of Textures&lt;/h2>
&lt;p>Textures are used for in many ways to affect the representation of a mesh.&lt;/p>
&lt;h3 id="solid-textures">Solid Textures&lt;/h3>
&lt;p>Textures that are indexed in a 3 demension sense.&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: Difficult to get a 3D Texture, comes with memory/performance issues with it&lt;/p>
&lt;h3 id="displacement-textures">Displacement Textures&lt;/h3>
&lt;p>Textures that can be used to represent the preturb of the surface geometry&lt;/p>
&lt;p>&lt;strong>Note&lt;/strong>: The affects that actual geometry and is expensive&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/displacement.png"
width="994"
height="652"
srcset="/p/3d-graphics-textures/displacement_hu0878cbf3ff795e3faa645ef1ec7e917f_755235_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/displacement_hu0878cbf3ff795e3faa645ef1ec7e917f_755235_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="displacement"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;h3 id="bump-map-textures">Bump Map Textures&lt;/h3>
&lt;p>Textures that are used to trick the lighting model by perturbing the normals of the surface&lt;/p>
&lt;p>&lt;strong>Note:&lt;/strong> This not not affect the geomtry of the object, only lies to the lighting model about the object&amp;rsquo;s geometry&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/bump.png"
width="3072"
height="1170"
srcset="/p/3d-graphics-textures/bump_hu7b5da329676cac4327032cdec4342c46_2776485_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/bump_hu7b5da329676cac4327032cdec4342c46_2776485_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="bump"
class="gallery-image"
data-flex-grow="262"
data-flex-basis="630px"
>&lt;/p>
&lt;h3 id="enviornmentreflection-textures">Enviornment/Reflection Textures&lt;/h3>
&lt;p>A texture that represents an object&amp;rsquo;s surroundings&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-textures/env.png"
width="256"
height="256"
srcset="/p/3d-graphics-textures/env_hufb910f18aa5e499e1dcdb2c9847ba5f8_115068_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/env_hufb910f18aa5e499e1dcdb2c9847ba5f8_115068_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="env"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>
&lt;img src="/p/3d-graphics-textures/envexample.png"
width="625"
height="461"
srcset="/p/3d-graphics-textures/envexample_hu2353b1bbf77c48108acc271b6e3bb69e_556777_480x0_resize_box_3.png 480w, /p/3d-graphics-textures/envexample_hu2353b1bbf77c48108acc271b6e3bb69e_556777_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="envEx"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>&lt;/p></description></item><item><title>3D Graphics: Meshing</title><link>/p/3d-graphics-meshing/</link><pubDate>Sun, 23 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-meshing/</guid><description>&lt;img src="https://i.stack.imgur.com/Bk826.png" alt="Featured image of post 3D Graphics: Meshing" />&lt;p>A mesh is a collection of primitives shape that make up an overarching model
&lt;img src="/p/3d-graphics-meshing/mesh.png"
width="1000"
height="1080"
srcset="/p/3d-graphics-meshing/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/mesh_huca8b3e1b9a099698e7e755ead9321f30_581287_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Mesh"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="222px"
>&lt;/p>
&lt;h2 id="storing-mesh-data">Storing Mesh Data&lt;/h2>
&lt;h3 id="storing-mesh">Storing Mesh&lt;/h3>
&lt;p>To efficiently store mesh data, we want to reduce the amount of redundancy when rendering the primitive shapes.&lt;/p>
&lt;p>We do this by storing all the verticies of involved in the mesh and storing all the different combination of the verticies that make up our primitive shape&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0 \\
V_1 \\
V_2 \\
&amp;hellip; \\
V_n
\end{bmatrix}
$$&lt;/p>
&lt;p>Primitive Shape Data
$$
\begin{bmatrix}
0,1,2 \\
3,4,5 \\
&amp;hellip; \\
n-2, n-1, n
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="vertex-order-matters">Vertex Order Matters&lt;/h3>
&lt;p>In practice, the order of the verticies of a mesh is used to determine the &lt;strong>normal&lt;/strong> (an indication of which side of the primitive is the front and back). Putting the verticies in the wrong order can get results that are unexpected&lt;/p>
&lt;h3 id="culling">Culling&lt;/h3>
&lt;p>Culling is a technique used to reduce the amount of primitve shapes being rendered by the render engine. It expects to render only one side of the primitve shape, the front side! (Unless specified that it&amp;rsquo;s double sided).&lt;/p>
&lt;p>Determining the side of the primitve is done through vector math!&lt;/p>
&lt;p>&lt;strong>Calculating the angle:&lt;/strong>&lt;/p>
&lt;p>Cos(ϴ) = -V * N&lt;/p>
&lt;p>V = viewing vector (from the camera to the object)&lt;/p>
&lt;p>N = normal vector&lt;/p>
&lt;p>ϴ &amp;gt; 0 = front facing
ϴ &amp;lt;= 0 = back facing&lt;/p>
&lt;p>Having the wrong normals can cause a triangle to not be rendered&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/wrongIndex.png"
width="450"
height="193"
srcset="/p/3d-graphics-meshing/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/wrongIndex_huf10670131e768ee8203a4a4dc1184e34_52232_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="indexDif"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="559px"
>&lt;/p>
&lt;h3 id="storing-normals">Storing Normals&lt;/h3>
&lt;p>Normals could be calculated per triangle using some math, but that would introduce problems when wanting to create smooth surfraces of multiple primitives.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/interpResult.png"
width="670"
height="355"
srcset="/p/3d-graphics-meshing/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/interpResult_hubbf89ba6fc3ac67518552fdaf31837fe_83631_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="interpResult"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="452px"
>&lt;/p>
&lt;p>To avoid this issue, we give every &lt;strong>vertex&lt;/strong> a normal vector and interpolate normal vectors intermediate points on the primitive&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/normalInterpolation.png"
width="670"
height="247"
srcset="/p/3d-graphics-meshing/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/normalInterpolation_hu8c235c55772e7a776d5c821d4c16dfc7_48976_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="normalInterp"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="651px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0, N_0 \\
V_1, N_1 \\
V_2, N_2 \\
&amp;hellip; \\
V_n, N_n
\end{bmatrix}
$$&lt;/p>
&lt;h3 id="storing-textures">Storing Textures&lt;/h3>
&lt;p>We have an object with a correct shape, but what if we want to paint it with an image? This is done through the power of UV mapping.&lt;/p>
&lt;p>UV mapping is the process of assign a pixel on the texture/image with a pixel on the model. We assign a vertex on our mesh with a 2D coordinate corresponding a pixel on the texture. Other UV positions on the non-vertex mesh pixels are interpolated.&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-meshing/UVMapping.png"
width="640"
height="336"
srcset="/p/3d-graphics-meshing/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_480x0_resize_box_3.png 480w, /p/3d-graphics-meshing/UVMapping_hud32cc52ffbba488d832b819481aef1c5_112050_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="UVMapping"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="457px"
>&lt;/p>
&lt;p>Our vertex data storage now looks like this:&lt;/p>
&lt;p>Vertice Data
$$
\begin{bmatrix}
V_0, N_0, (U,V)_0 \\
V_1, N_1, (U,V)_1 \\
V_2, N_2, (U,V)_2 \\
&amp;hellip; \\
V_n, N_n, (U,V)_n
\end{bmatrix}
$$&lt;/p></description></item><item><title>3D Graphics: Hierarchy Models</title><link>/p/3d-graphics-hierarchy-models/</link><pubDate>Thu, 20 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-hierarchy-models/</guid><description>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png" alt="Featured image of post 3D Graphics: Hierarchy Models" />&lt;h2 id="matrix-transformation">Matrix Transformation&lt;/h2>
&lt;p>The reason we keep things like translations as a matrix transformation instead of a simple collumn addition is for &lt;strong>EFFICIENCY&lt;/strong>.&lt;/p>
&lt;p>If we wanted to do multiple transformations on an objects.&lt;/p>
&lt;p>$$(M_N * &amp;hellip; * M_1) * P $$&lt;/p>
&lt;p>is easier than&lt;/p>
&lt;p>$$(M_2 * ((M_1 * P ) + T_1) + T_2)$$&lt;/p>
&lt;p>We can calculate the overall matrix onces instead of doing multiple computations for multiple points&lt;/p>
&lt;h3 id="types-of-transformation">Types of transformation&lt;/h3>
&lt;p>$$T(x,y,z) = Translation$$
$$S(x,y,z) = Scaling$$
$$Rx(theta) = \text{Rotation over x-axis}$$
$$Ry(theta) = \text{Rotation over y-axis}$$
$$Rz(theta) = \text{Rotation over z-axis}$$&lt;/p>
&lt;h3 id="example-of-transformation">Example of transformation&lt;/h3>
&lt;p>Let&amp;rsquo;s say we want to rotate an object ϴ on a 2D plane with a point P as it&amp;rsquo;s rotation pivot:&lt;/p>
&lt;ol>
&lt;li>You want to first translate the object to have point P of the object be at the origin (anything at the origin will not be affected during scaling, translation, or rotation)
&lt;ol>
&lt;li>$$T(-p.x,-p.y,-p.z) = P $$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Next you want to do a rotation around the z-axis (since we are in 2D)
&lt;ol>
&lt;li>$$Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Finally you want to move the object back to its original position
&lt;ol>
&lt;li>$$T(p.x, p.y, p.z) * Rz(ϴ) * T(-p.x, -p.y, -p.z) = P$$&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>&lt;em>Note: Matrix operations go right to left, you need to order the matricies in the order of the transformations correctly&lt;/em>&lt;/p>
&lt;h2 id="hierachical-models">Hierachical Models&lt;/h2>
&lt;p>With most models, we want certain objects to move similar to joints, where they move if a parent object moves. This is a form called &lt;strong>Hierachical modeling&lt;/strong>&lt;/p>
&lt;p>You can view it like this:&lt;/p>
&lt;ul>
&lt;li>World
&lt;ul>
&lt;li>Body
&lt;ul>
&lt;li>Arms
&lt;ul>
&lt;li>Hands
&lt;ul>
&lt;li>Fingers&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Head
&lt;ul>
&lt;li>Ears&lt;/li>
&lt;li>Eyes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>You can view this as a tree of different matrix transformations&lt;/p>
&lt;h3 id="coordinate-frames">Coordinate Frames&lt;/h3>
&lt;p>You can imagine a coordinate frame as a screenshot of the coordinate system/unit vectors transposed and rotated in some fashion.&lt;/p>
&lt;p>In a hierachical system, each parent-child relationship comes with a coordinate frame that dictates the world view of the particular object&lt;/p>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/coordinateFrames.png"
width="332"
height="504"
srcset="/p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/coordinateFrames_hu501f4754882fa586b38eda48d2318a36_128655_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="frames"
class="gallery-image"
data-flex-grow="65"
data-flex-basis="158px"
>&lt;/p>
&lt;p>In a hiearchy, a coordinate frame is made up from the previous coordinate frames from the parents above.&lt;/p>
&lt;p>In the above example:
$$C_0 = T_0$$
$$C_1 = T_1 * R_{x_1}(\theta) * C_0$$
$$C_2 = T_2 * R_{x_2}(\theta) * C_1$$&lt;/p>
&lt;p>Each object uses their own coordinate frame to determine the position of their pixels&lt;/p>
&lt;p>$$\text{Blue} = C_0 * T * S$$
$$\text{Red} = C_1 * T * S$$
$$\text{Green} = C_2 * T * S$$&lt;/p>
&lt;p>With these, if a parents moves in someway, the children will also be affected by them.&lt;/p>
&lt;p>Another way to view the relationships is like this:
&lt;img src="/p/3d-graphics-hierarchy-models/hierarchyTree.png"
width="658"
height="766"
srcset="/p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/hierarchyTree_hu379017cd298dd767776d8bc8dfe8c0eb_70060_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="hierarchyTree"
class="gallery-image"
data-flex-grow="85"
data-flex-basis="206px"
>&lt;/p>
&lt;p>Now to actually do the math to create these objects, you need to create the overaching matricies multipled with the points of the object.&lt;/p>
&lt;h3 id="generating-the-hierachical-matrix">Generating the hierachical matrix&lt;/h3>
&lt;p>You can view this process as a in-order traversal/DFS using a stack. The stack represents the current overall matrix while you push and pop mini transformation components.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>We start with generating the blue block by adding the first coordinate frame into the stack and then adding the block&amp;rsquo;s independent transformations into the stack.
&lt;img src="/p/3d-graphics-hierarchy-models/step1.png"
width="928"
height="848"
srcset="/p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step1_hu722deab187dd036be294eea709522527_278667_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step1"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="262px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then remove the independent transformations of the blue block and add in the additional transformations that make up our next coordinate frame. We then add in the independent transforations of the red block
&lt;img src="/p/3d-graphics-hierarchy-models/step2.png"
width="940"
height="866"
srcset="/p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/step2_hu5f9bd2ef6a1227cd1b6cc0f6d312f687_91339_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step2"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="260px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>We then perform the same steps, remove independent transformations -&amp;gt; create next coordinate frame, add in new independent transformations&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/p/3d-graphics-hierarchy-models/finalStep.png"
width="804"
height="744"
srcset="/p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_480x0_resize_box_3.png 480w, /p/3d-graphics-hierarchy-models/finalStep_hu371377724c1064b1fa38f67b56912919_257468_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="step3"
class="gallery-image"
data-flex-grow="108"
data-flex-basis="259px"
>&lt;/p></description></item><item><title>3D Graphics Intro</title><link>/p/3d-graphics-intro/</link><pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate><guid>/p/3d-graphics-intro/</guid><description>&lt;img src="https://cdn5.vectorstock.com/i/1000x1000/47/14/3d-coordinate-axis-vector-7814714.jpg" alt="Featured image of post 3D Graphics Intro" />&lt;h1 id="overview--affine-transformation">Overview &amp;amp; Affine Transformation&lt;/h1>
&lt;h2 id="3d-rotation">3D Rotation&lt;/h2>
&lt;ul>
&lt;li>Cos(theta) in the matrix scaling spots&lt;/li>
&lt;li>Sin(theta) and -Sin(theta) in the matrix sheering spots&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) \\
Sin(ϴ) &amp;amp; Cos(ϴ)
\end{bmatrix}
$$&lt;/p>
&lt;p>&lt;strong>3D Rotation&lt;/strong>
$$
\begin{bmatrix}
Cos(ϴ) &amp;amp; -Sin(ϴ) &amp;amp; 0 \\
Sin(ϴ) &amp;amp; Cos(ϴ) &amp;amp; 0 \\\
0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}
$$&lt;/p>
&lt;h2 id="homogeneous-coordinates">Homogeneous Coordinates&lt;/h2>
&lt;p>Have an extra collumn in the transformation matrix to represent translation&lt;/p>
&lt;p>&lt;strong>2D Translation&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Move to a 3D dimension and make the third collumn in the matrix a translation vector&lt;/li>
&lt;/ul>
&lt;p>$$
\begin{bmatrix}
x+1 \\
y \\
0
\end{bmatrix}=
\begin{bmatrix}
x+1\\
y
\end{bmatrix}=
\begin{bmatrix}
1 &amp;amp; 0 &amp;amp; 1 \\
0 &amp;amp; 1 &amp;amp; 0 \\
0 &amp;amp; 0 &amp;amp; 0
\end{bmatrix}
*
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
$$&lt;/p></description></item></channel></rss>