[{"content":"I\u0026rsquo;ve been exploring Direct X 3D and it\u0026rsquo;s implementation as a Graphics Engine! Wanted to share my notes on how to set it up in a quick and simple blog.\nThere is a bunch of overhead involving creating a window before setuping Direct X 3D, I will not be covering it in this blog, but plan to cover it in another blog.\nAll the code related to the contents of this blog come from my repository on Github\nDirect X Pipeline Before rendering an object in Direct X, there are components that need to be initialized:\n Device Swap Chain Context  Device The device is a component of Direct3D that allows you to allocate data structures and store information on the GPU about the current rendering state\nExamples of uses of the device are:\n RenderTargetView DepthStencilState CreateTexture2D CreateBuffer CreateVertexShader CreatePixelShader CreateInputLayout  For more information about the device\nSwap Chain The swap chain represent the current frame being presented to you, the viewer. The swap chain has a lot of settings that can be adjusted but the idea is that you have two(or more) buffers, the front and back buffers.\nThe names front and back represent which buffer is the one being presented. The back buffer will be where current draw calls are being directed to while the front buffer will be what the viewer sees.\nOnce the drawing of the back buffer has been completed, the buffers will be switched and the previous back buffer will be the current front buffer while the previous front buffer will be the current back buffer\n A representation of a triple buffer swap chain \nFor more information about the swap chain\nContext The context holds all the resources being used in pipeline:\n VertexBuffer : A collection of vertex data of the current object IndexBuffer : A collection of indexes representing the order of verticies to use when drawing the desired topology shape VerexShader : GPU instructions used to perform mathmatical operations to each vertex positioning before presentation PixelShader : GPU instructions used to perform mathmatical operations to each vertex coloring before presentation Topology : The geometric shape to use when rendering verticies (EX: Lines \u0026amp; Triangles) InputLayout : A definition of the low level layout of data being sent to the GPU and their shaders (Vertex Data Definition, Color Data Definition, etc) ConstantBuffer : A buffer that is filled with custom data and available to the designated shader at all times. (Data can only be updated by replacing the buffer with an updated version)  The context allows you to attach created data structures(listed above) and attach them to the current render pipeline\nFor more information about the context\nExtra There are more parts of the pipeline not covered in this readme\n Image of Direct3D Pipeline \nFor more information of the pipeline\nCreating an Object Creating an object involves a combination of using the device to allocate data structures(like buffers) and using the context to attach them to the pipeline. Every object must go through creating, defining, and attaching pipeline resources before being raterized to the swap chain buffers\nExample of creating a box struct Vertex { struct { float x; float y; float z; } pos;\t}; ////Create Vertex Buffer (2d Triangle) const Vertex vertices[] = { {-1.0f, -1.0f, -1.0f}, {1.0f, -1.0f, -1.0f}, {-1.0f, 1.0f, -1.0f}, {1.0f, 1.0f, -1.0f}, {-1.0f, -1.0f, 1.0f}, {1.0f, -1.0f, 1.0f}, {-1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f} }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pVertexBuffer; D3D11_BUFFER_DESC bd = {}; bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; bd.Usage = D3D11_USAGE_DEFAULT; bd.CPUAccessFlags = 0u; bd.MiscFlags = 0u; bd.ByteWidth = sizeof(vertices); bd.StructureByteStride = sizeof(Vertex); D3D11_SUBRESOURCE_DATA sd = {}; sd.pSysMem = vertices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;bd, \u0026amp;sd, \u0026amp;pVertexBuffer)); //// Attach Vertex Buffer to Pipeline const UINT stride = sizeof(Vertex); const UINT offset = 0u; pContext-\u0026gt;IASetVertexBuffers(0u,1u, pVertexBuffer.GetAddressOf(), \u0026amp;stride, \u0026amp;offset); //// Create Index Buffer (Used for reusing predfined vertices for multiple triangles) const unsigned short indices[] = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4, }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pIndexBuffer; D3D11_BUFFER_DESC ibd = {}; ibd.BindFlags = D3D11_BIND_INDEX_BUFFER; ibd.Usage = D3D11_USAGE_DEFAULT; ibd.CPUAccessFlags = 0u; ibd.MiscFlags = 0u; ibd.ByteWidth = sizeof(indices); ibd.StructureByteStride = sizeof(unsigned short); D3D11_SUBRESOURCE_DATA isd = {}; isd.pSysMem = indices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;ibd, \u0026amp;isd, \u0026amp;pIndexBuffer)); //// Attach Index Buffer to Pipeline pContext-\u0026gt;IASetIndexBuffer(pIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0u); //// Create const buffer for transformation matrix (Do matrix transformation instead of moving sending a new vertex buffer) struct ConstantBuffer { dx::XMMATRIX transform; }; const ConstantBuffer cb = { { dx::XMMatrixTranspose( dx::XMMatrixRotationZ(angle) * dx::XMMatrixRotationX(angle) * dx::XMMatrixTranslation(x, 0.0f, z + 4.0f) * dx::XMMatrixPerspectiveLH(1.0f, 3.0f/ 4.0f, 0.5f, 10.0f) ) } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer; D3D11_BUFFER_DESC cbd = {}; cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd.Usage = D3D11_USAGE_DYNAMIC; cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; cbd.MiscFlags = 0u; cbd.ByteWidth = sizeof(cb); cbd.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd = {}; csd.pSysMem = \u0026amp;cb; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd, \u0026amp;csd, \u0026amp;pConstantBuffer)); //// Attach const buffer to vertex shader pContext-\u0026gt;VSSetConstantBuffers(0u, 1u, pConstantBuffer.GetAddressOf()); //// Create another constant buffer for tagging triangle indexes to colors (individual colors per cube face) struct ConstantBuffer2 { struct { float r; float g; float b; float a; }face_colors[6]; }; const ConstantBuffer2 cb2 = { { {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 1.0f}, } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer2; D3D11_BUFFER_DESC cbd2 = {}; cbd2.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd2.Usage = D3D11_USAGE_DEFAULT; cbd2.CPUAccessFlags = 0u; cbd2.MiscFlags = 0u; cbd2.ByteWidth = sizeof(cb2); cbd2.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd2 = {}; csd2.pSysMem = \u0026amp;cb2; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd2, \u0026amp;csd2, \u0026amp;pConstantBuffer2)); //// Attach const buffer to vertex shader pContext-\u0026gt;PSSetConstantBuffers(0u, 1u, pConstantBuffer2.GetAddressOf()); //// Create Pixel Shader wrl::ComPtr\u0026lt;ID3D11PixelShader\u0026gt; pPixelShader; wrl::ComPtr\u0026lt;ID3DBlob\u0026gt; pBlob; GFX_THROW_INFO(D3DReadFileToBlob(L\u0026#34;PixelShader.cso\u0026#34;, \u0026amp;pBlob)); GFX_THROW_INFO(pDevice-\u0026gt;CreatePixelShader(pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), nullptr, \u0026amp;pPixelShader)); //// Attach Pixel Shader pContext-\u0026gt;PSSetShader(pPixelShader.Get(), nullptr, 0u); // Create Vertex Shader wrl::ComPtr\u0026lt;ID3D11VertexShader\u0026gt; pVertexShader; GFX_THROW_INFO(D3DReadFileToBlob(L\u0026#34;VertexShader.cso\u0026#34;, \u0026amp;pBlob)); GFX_THROW_INFO(pDevice-\u0026gt;CreateVertexShader(pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), nullptr, \u0026amp;pVertexShader)); // Attach Vertex Shader to Pipeline //pContext-\u0026gt;VSSetShader(pVertexShader.Get(), nullptr, 0u);  //// Input (vertex) layout (2d position only) wrl::ComPtr\u0026lt;ID3D11InputLayout\u0026gt; pInputLayout; const D3D11_INPUT_ELEMENT_DESC ied[] = { //\t// Reads positions as 2 4 byte values \t{\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, //\t// Reads color as 4 byte values and normalizes them from 0 - 1 \t{\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; GFX_THROW_INFO(pDevice-\u0026gt;CreateInputLayout( ied, (UINT)std::size(ied), pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), \u0026amp;pInputLayout )); //// Bind Input Layout pContext-\u0026gt;IASetInputLayout(pInputLayout.Get()); // Bind Render Target // **COME BACK TO THIS IN CASE ERROR** pContext-\u0026gt;OMSetRenderTargets(1u, pTarget.GetAddressOf(), pDSV.Get()); // Set primitive topology to triangle list (groups of verticies make multiple triangles) pContext-\u0026gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); GFX_THROW_INFO_ONLY(pContext-\u0026gt;DrawIndexed(count, 0u, 0u)); Vertex Buffer Device Step\nstruct Vertex { struct { float x; float y; float z; } pos;\t}; ////Create Vertex Buffer (2d Triangle) const Vertex vertices[] = { {-1.0f, -1.0f, -1.0f}, {1.0f, -1.0f, -1.0f}, {-1.0f, 1.0f, -1.0f}, {1.0f, 1.0f, -1.0f}, {-1.0f, -1.0f, 1.0f}, {1.0f, -1.0f, 1.0f}, {-1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f} }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pVertexBuffer; D3D11_BUFFER_DESC bd = {}; bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; bd.Usage = D3D11_USAGE_DEFAULT; bd.CPUAccessFlags = 0u; bd.MiscFlags = 0u; bd.ByteWidth = sizeof(vertices); bd.StructureByteStride = sizeof(Vertex); D3D11_SUBRESOURCE_DATA sd = {}; sd.pSysMem = vertices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;bd, \u0026amp;sd, \u0026amp;pVertexBuffer)); Context Step\n//// Attach Vertex Buffer to Pipeline const UINT stride = sizeof(Vertex); const UINT offset = 0u; pContext-\u0026gt;IASetVertexBuffers(0u,1u, pVertexBuffer.GetAddressOf(), \u0026amp;stride, \u0026amp;offset); Index Buffer Device Step\n//// Create Index Buffer (Used for reusing predfined vertices for multiple triangles) const unsigned short indices[] = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4, }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pIndexBuffer; D3D11_BUFFER_DESC ibd = {}; ibd.BindFlags = D3D11_BIND_INDEX_BUFFER; ibd.Usage = D3D11_USAGE_DEFAULT; ibd.CPUAccessFlags = 0u; ibd.MiscFlags = 0u; ibd.ByteWidth = sizeof(indices); ibd.StructureByteStride = sizeof(unsigned short); D3D11_SUBRESOURCE_DATA isd = {}; isd.pSysMem = indices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;ibd, \u0026amp;isd, \u0026amp;pIndexBuffer)); Context Step\n//// Attach Index Buffer to Pipeline pContext-\u0026gt;IASetIndexBuffer(pIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0u); Constant Buffers (Vertex and Pixel) Device Step\n//// Create const buffer for transformation matrix (Do matrix transformation instead of moving sending a new vertex buffer) struct ConstantBuffer { dx::XMMATRIX transform; }; const ConstantBuffer cb = { { dx::XMMatrixTranspose( dx::XMMatrixRotationZ(angle) * dx::XMMatrixRotationX(angle) * dx::XMMatrixTranslation(x, 0.0f, z + 4.0f) * dx::XMMatrixPerspectiveLH(1.0f, 3.0f/ 4.0f, 0.5f, 10.0f) ) } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer; D3D11_BUFFER_DESC cbd = {}; cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd.Usage = D3D11_USAGE_DYNAMIC; cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; cbd.MiscFlags = 0u; cbd.ByteWidth = sizeof(cb); cbd.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd = {}; csd.pSysMem = \u0026amp;cb; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd, \u0026amp;csd, \u0026amp;pConstantBuffer)); Context Step\n//// Attach const buffer to vertex shader pContext-\u0026gt;VSSetConstantBuffers(0u, 1u, pConstantBuffer.GetAddressOf()); Device Step\n//// Create another constant buffer for tagging triangle indexes to colors (individual colors per cube face) struct ConstantBuffer2 { struct { float r; float g; float b; float a; }face_colors[6]; }; const ConstantBuffer2 cb2 = { { {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 1.0f}, } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer2; D3D11_BUFFER_DESC cbd2 = {}; cbd2.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd2.Usage = D3D11_USAGE_DEFAULT; cbd2.CPUAccessFlags = 0u; cbd2.MiscFlags = 0u; cbd2.ByteWidth = sizeof(cb2); cbd2.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd2 = {}; csd2.pSysMem = \u0026amp;cb2; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd2, \u0026amp;csd2, \u0026amp;pConstantBuffer2)); Context Step\n//// Attach const buffer to vertex shader pContext-\u0026gt;PSSetConstantBuffers(0u, 1u, pConstantBuffer2.GetAddressOf()); Input Layout Device Step\n//// Input (vertex) layout (2d position only) wrl::ComPtr\u0026lt;ID3D11InputLayout\u0026gt; pInputLayout; const D3D11_INPUT_ELEMENT_DESC ied[] = { //\t// Reads positions as 2 4 byte values \t{\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, //\t// Reads color as 4 byte values and normalizes them from 0 - 1 \t{\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; GFX_THROW_INFO(pDevice-\u0026gt;CreateInputLayout( ied, (UINT)std::size(ied), pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), \u0026amp;pInputLayout )); Context Step\n//// Bind Input Layout pContext-\u0026gt;IASetInputLayout(pInputLayout.Get()); Topology Context Step\n// Set primitive topology to triangle list (groups of verticies make multiple triangles) pContext-\u0026gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); Drawable \u0026amp; Bindable Framework Design The Drawable \u0026amp; Bindable Graphics framework was designed by PlanetChilli (Otherwise known as ChiliTomatoNoodle on yt)\nThe framework is designed to shorten and abstract the creation of objects in DirectX. There are 3 parts of it, the Graphics interface, the Bindable Interface, and the Drawable Interface. These all work together to allow multiple object creation in a single 3D scene\nGraphics This interface is the main controller of 3D scene\nPipeline setup This interface will handle the creation of the crucial components of the pipeline (Device, Swap Chain, Context)\nAlong with that, it will keep a reference to:\n Device Swap Chain Context RenderTargetView : A pipeline handled data structure for referencing the current back buffer DepthStencilView : A pipeline handled data structure for referncing the current depth view frame A projection matrix : Used for translating the vertex position to 3D camera space (perspective, orthographic)  There are also five key functions to the Graphics interface:\n EndFrame() : Presents the current back buffer by switching the front and back buffer ClearBuffer() : Wipes everything on the current back buffer DrawIndex() : Draws onto the back buffer with the resources attached to the pipeline (assumes that indexing is done, can be changed to work without indexing) SetProjection() : Updates the current projection matrix in the 3D Scene GetProjection() : Returns the current project matrix being used in the 3D scene  Bindable This interface represents one of the data structures that can be attached to the pipline\nSome examples of Bindable structures are:\n VertexBuffer ConstantBuffers IndexBuffer InputLayout Shaders (Vertex and Pixel) Topology etc  The only function required of a Bindable is called Bind(). The expected implementation is that the context step of attaching to the pipeline is done in this function while the device step is handled in the constructor.\nHelper Functions There are helper functions that only Bindable objects can call, these are implemented by the Bindable interface and allow Bindables to interact with the Graphics instance:\n GetContext() : Returns the current reference to the Context of a Graphics instance GetDevice() : Returns the current reference to the Device of a Graphics instance  Drawable This interface represents a drawable object such as a Box, Triangle, or any other 3D(or 2D) object\nThere are 5 functions tied to a Drawable:\n GetTransformXM() : Returns the current transformation matrix of the object (rotation + translation + etc, excluding the projection matrix stored in Graphics) Draw() : Binds the Drawable\u0026rsquo;s bindables to the pipeline and tells the Graphics instance to draw it AddBind() : Adds a bindable to the Drawable\u0026rsquo;s collection AddIndexBuffer() : Performs the same as AddBind() except with the condition that only 1 IndexBuffer can be added to a Drawable object Update() : Performs changes to a Drawable\u0026rsquo;s state based off a change of time (movement, rotation, scaling, etc)  The Drawable interface already implements the crucial functions listed, new Drawables will only need to implement certain functions due to behavior varying between Drawables:\n GetTransformXM() Update()  The expected behavior is that creating Bindables and adding them to Drawables are done in a Drawable constructor\nExample of the Drawable \u0026amp; Bindable Framework Box.h\n#include \u0026#34;Drawable.h\u0026#34;class Box : public Drawable { public: Box(Graphics\u0026amp; gfx, std::mt19937\u0026amp; rng, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; adist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; ddist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; odist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; rdist); void Update(float dt) noexcept override; DirectX::XMMATRIX GetTransformXM() const noexcept override; private: float r; // z-axis \tfloat roll = 0.0f; // x-axis \tfloat pitch = 0.0f; // y-axis \tfloat yaw = 0.0f; float theta; float phi; float chi; // z-axis \tfloat droll; // x-axis \tfloat dpitch; // y-axis \tfloat dyaw; float dtheta; float dphi; float dchi; }; Box.cpp (constructor)\nBox::Box(Graphics\u0026amp; gfx, std::mt19937\u0026amp; rng, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; adist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; ddist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; odist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; rdist) : r(rdist(rng)), droll(ddist(rng)), dpitch(ddist(rng)), dyaw(ddist(rng)), dphi(odist(rng)), dtheta(odist(rng)), dchi(odist(rng)), chi(adist(rng)), theta(adist(rng)), phi(adist(rng)) { struct Vertex { struct { float x; float y; float z; }pos; struct { unsigned char r; unsigned char g; unsigned char b; }color; }; const std::vector\u0026lt;Vertex\u0026gt; vertices = { {-1.0f, -1.0f, -1.0f, 255,0,255 }, {1.0f, -1.0f, -1.0f, 255,0,0 }, {-1.0f, 1.0f, -1.0f, 0,255,0}, {1.0f, 1.0f, -1.0f, 0,0,255}, {-1.0f, -1.0f, 1.0f, 255,255,0}, {1.0f, -1.0f, 1.0f, 0,255,255}, {-1.0f, 1.0f, 1.0f, 255,255,255}, {1.0f, 1.0f, 1.0f, 0,255,255} }; AddBind(std::make_unique\u0026lt;VertexBuffer\u0026lt;Vertex\u0026gt;\u0026gt;(gfx, vertices)); auto pvs = std::make_unique\u0026lt;VertexShader\u0026gt;(gfx, L\u0026#34;VertexShader.cso\u0026#34;); auto pvbc = pvs-\u0026gt;GetByteCode(); AddBind(std::move(pvs)); AddBind(std::make_unique\u0026lt;PixelShader\u0026gt;(gfx, L\u0026#34;PixelShader.cso\u0026#34;)); const std::vector\u0026lt;unsigned short\u0026gt; indices = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4 }; AddIndexBuffer(std::make_unique\u0026lt;IndexBuffer\u0026gt;(gfx, indices)); struct FaceColorConstantBuffer { struct { float r; float g; float b; float a; }face_colors[6]; }; const std::vector\u0026lt;D3D11_INPUT_ELEMENT_DESC\u0026gt; ied = { {\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, {\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; AddBind(std::make_unique\u0026lt;InputLayout\u0026gt;(gfx, ied, pvbc)); AddBind(std::make_unique\u0026lt;Topology\u0026gt;(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST)); AddBind(std::make_unique\u0026lt;TransformConstantBuffer\u0026gt;(gfx, *this)); } Box.cpp (Update)\nvoid Box::Update(float dt) noexcept { roll += droll * dt; pitch += dpitch * dt; yaw += dyaw * dt; phi += dphi * dt; chi += dchi * dt; } Box.cpp (GetTransformXM)\nDirectX::XMMATRIX Box::GetTransformXM() const noexcept { return DirectX::XMMatrixRotationRollPitchYaw(pitch, yaw, roll) * DirectX::XMMatrixTranslation(r, 0.0f, 0.0f)* DirectX::XMMatrixRotationRollPitchYaw(theta, phi, chi)* DirectX::XMMatrixTranslation(0.0f, 0.0f, 20.0f); } Main\nstd::mt19937 rng(std::random_device{}()); std::uniform_real_distribution\u0026lt;float\u0026gt; adist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; ddist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; odist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; rdist(6.0f, 20.0f); for (auto i = 0; i \u0026lt; 150; i++) { boxes.push_back(std::make_unique\u0026lt;Box\u0026gt;( (Graphics instance here), rng, adist, ddist, odist, rdist )); } (Graphics instance here).SetProjecton(DirectX::XMMatrixPerspectiveLH(1.0, 3.0f / 4.0f, 0.5f, 40.0f)); Some other function that executes a frame\nauto dt = timer.Mark(); (Graphics instance here).ClearBuffer(0.07f, 0.0f, 0.12f); for (auto\u0026amp; b : boxes) { b-\u0026gt;Update(dt/8); b-\u0026gt;Draw((Graphics instance here)); } (Graphics instance here).EndFrame();  Result of Code \nGIF Source Link\n","date":"2021-12-22T18:11:43-08:00","image":"https://media.giphy.com/media/hVsP8KfbcwItVhMg5s/giphy.gif","permalink":"/p/directx-3d-intro/","title":"DirectX 3D Intro"},{"content":"Hi Guys, this is my first time using Hugo, so hope this all comes out okay\u0026hellip;\n","date":"2021-11-15T00:00:00Z","permalink":"/p/initial-post/","title":"Initial Post"}]