[{"content":"Welcome! Welcome to the top down shooter tutorial! The purpose of this blog is to be used to follow along during the game development club tutorial meeting but all are welcome to view this and learn from it!\nGetting Started Downloading Unity If you don\u0026rsquo;t already have Unity downloaded, go ahead and download the hub\nHub Finishing signing in and navigate to the editor installation area\nEditor This tutorial will be using version 2021.3.11f1 but what matters is that you use a version that is 2021.3.x and is LTS\nCreating Project We\u0026rsquo;re going to be creating a top down shooter so we\u0026rsquo;re going to want to use the 2D URP (Universal Render Pipeline). To ensures that the proper render settings are set\nproject Unity Introduction In case unity is new to you, here is a quick overivew of the parts of the unity editor\nHierarchy This section of the editor shows you all the gameobjects in your scene and their relations to each other\nhierarchy Views There are two different cameras in use in the unity editor: the game camera \u0026amp; the scene camera\nviews Scene View The scene view is connected to the scene camera, this is controllable by the user and allows you to see around your scene\nGame View The game view is connected to the game camera, this is what the player potentially will see (potentially because there can be more than one game camera in a scene). This is represented by an object in your scene marked as a camera. You can only move it if you move the camera object.\nInspector Unity is a component based engine, this means that every object stores a collection of different scripts that do different things, they are all ran doing the object\u0026rsquo;s execution\ninspector Project \u0026amp; Console Project allows you to view all the assets you have available for use\nproject The console is a window used for debugging, it allows you to print information from your code\nconsole Player Getting started on making this top down, let\u0026rsquo;s start with the player\nSprite We need some way to represent the character! We\u0026rsquo;re going to use the default spirtes available in unity to create the player\nWe\u0026rsquo;re going to create an empty gameboject and call it player\nWe\u0026rsquo;re going to creating the body and call it body and attach it to player spirte Let\u0026rsquo;s make this a tank! We\u0026rsquo;re going to attach the canon to it by creating another defaut sprite but attaching it to the body GameObject. We\u0026rsquo;re also going to scale it to become a canon. We\u0026rsquo;re also going to name this gameobject canon\ncanon Perfect! Now we have our tank\nMovement Now that we have a tank, let\u0026rsquo;s make it move!\nLet\u0026rsquo;s create our own custom code for this, navigate to the player object, click on it, and in the inspector click \u0026ldquo;add compoent\u0026rdquo;\nNavigate to the bottom of the of the components options and click \u0026ldquo;new script\u0026rdquo; and call it PlayerController\ncontroller Inside of our new script we\u0026rsquo;re going to write this!\nusing UnityEngine; public class PlayerController : MonoBehaviour { [SerializeField] private float movementSpeed = 1; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { HandleMovement(); } private void HandleMovement(){ // If our horizontal buttons are pressed (a or d) if(Input.GetButton(\u0026#34;Horizontal\u0026#34;)){ // which direction are we pressing (-1 == left and 1 == right) int direction = Input.GetAxis(\u0026#34;Horizontal\u0026#34;) \u0026lt; 0 ? -1 : 1; // Update our horizontal position // (multiple by Time.deltaTime to ensure proper movement if frames come faster or later than normal) transform.position = new Vector3(transform.position.x + (Time.deltaTime * direction * movementSpeed), transform.position.y, transform.position.z); } // If our vertical buttons are pressed (w or s) if(Input.GetButton(\u0026#34;Vertical\u0026#34;)){ // which direction are we pressing (-1 == down and 1 == up) int direction = Input.GetAxis(\u0026#34;Vertical\u0026#34;) \u0026lt; 0 ? -1 : 1; // Update our vertical position // (multiple by Time.deltaTime to ensure proper movement if frames come faster or later than normal) transform.position = new Vector3(transform.position.x, transform.position.y + (Time.deltaTime * direction * movementSpeed), transform.position.z); } } } This will update our position by a certain movement speed each frame if the vertical or horizontal buttons are pressed. This uses Unity\u0026rsquo;s input system (allows you to define specific inputs for actions)\nmovementFinished Shooting Now that we can move, let\u0026rsquo;s move on to shooting canonballs out of our canon!\nTo start off, let\u0026rsquo;s create out canon. We\u0026rsquo;re going to create the canon the same way we create the body of tank (with a circle sprite), but we\u0026rsquo;re going to scale down by some degree (you can choose what you\u0026rsquo;d like)\ncanonballs Prefabs Since this is our canon balls, we\u0026rsquo;re going to need to create multiple copies of these. Prefabs are a way to store your GameObjects as assets to be used and copied later. To make this canon a prefab you just need to drag the gameobject from the hierarchy to the project tab. Let\u0026rsquo;s make the player a prefab too!\nprefab With that we\u0026rsquo;re going to go back to our PlayerController and add a fire ability\n[SerializeField] private float movementSpeed = 1; [SerializeField] private GameObject canonBall; [SerializeField] private Transform canonSpawnLocation; // Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { HandleMovement(); HandleCanonFiring(); } private void HandleCanonFiring(){ if(Input.GetButtonDown(\u0026#34;Fire1\u0026#34;)){ Instantiate(canonBall, canonSpawnLocation.position, Quaternion.identity); } } Instantiate() spawns a prefab into the scene world, in this usage at the location where we want the canonballs to spawn at. You can ignore Quaternion.identity it represents a rotation of 0 degrees in all axis\u0026rsquo;s\nMake sure to set canonBall to be the canonball prefab, you can set this in the inspector. And set the canonSpawnLocation variable/field to be a transform of where you want the canonball to spawn at(you can do this by creating an empty gameobject and place it in the place you want the canonball to be placed)\ncanonBallSpawn canonSpawnLocation canonSpawnComplete As you can tell, our canonballs aren\u0026rsquo;t\u0026hellip;.moving\nRigidbody That\u0026rsquo;s where rigidbodies come into play! Unity has its own physics system that allows you to act physics upon game objects in your scene. Rigidbody allows you to act forces onto your object (like gravity, friction, and other forces)\nGo ahead an add a rigibody2D component to the canonball gameobject prefab\nrigidbody If you played the game as is you\u0026rsquo;ll see that the canonballs just falls downwards to the void, this is because by default, gravity is acted on the canonball. Since we\u0026rsquo;re doing a top down shooter, we don\u0026rsquo;t want this to happen.\nGo back to the rigidobdy2D component and set the gravity scale to 0, now gravity will no longer act upon our canonball. While you\u0026rsquo;re at it, go to the constraints section and toggle the free z-rotation option.\nrigidbodySetting Canonball Impulse Now that we can have forces act upon our canonballs, it\u0026rsquo;s time to write the code to do that. We\u0026rsquo;re going to create a new script called CanonballAction and attach it to the canonball gameobject prefab\nusing UnityEngine; public class CanonballAction : MonoBehaviour { private Rigidbody2D rb; // Start is called before the first frame update void Start() { // GetComponent grabs a reference of a type of component living on this gameobject // can be null if the type isn\u0026#39;t living on this gameobject rb = GetComponent\u0026lt;Rigidbody2D\u0026gt;(); } // Send this object in direction with a magnitude of force public void SendBall(Vector2 direction, float force){ if(rb == null){ rb = GetComponent\u0026lt;Rigidbody2D\u0026gt;(); } rb.AddForce(direction * force); } } We then go back to PlayerController and use the SendBall method to make the canonball to move on creation\n[SerializeField] private float movementSpeed = 1; [SerializeField] [Range(200, 500)] private float canonForce = 1; [SerializeField] private GameObject canonBall; [SerializeField] private Transform canonSpawnLocation; ... private void HandleCanonFiring(){ if(Input.GetButtonDown(\u0026#34;Fire1\u0026#34;)){ GameObject ball = Instantiate(canonBall, canonSpawnLocation.position, Quaternion.identity); CanonballAction action = ball.GetComponent\u0026lt;CanonballAction\u0026gt;(); if(action != null){ action.SendBall(canonSpawnLocation.up, canonForce); } } } And that we now have a shooting tank!\ntankShoot Aiming So\u0026hellip; we can move and shoot, but only aim in one direction what do I do if there is an enemy to my right, left, or behind me???\nRotating the body So if you remember our player\u0026rsquo;s hierarchy, it goes Empty - \u0026gt; Body -\u0026gt; Canon. And movement happens on Empty. Since we don\u0026rsquo;t want movement to be affected by rotation, we will enact rotation on the body! This way visually it will look like it\u0026rsquo;s rotated in underneath, but everything is still the same. We will go to PlayerController and add some stuff\n[SerializeField] private Transform body; ... void Update() { HandleMovement(); HandleCanonFiring(); HandleOrientation(); } ... // Does math to calculate the angle to rotate the body so it is facing towards the mouse private void HandleOrientation(){ Vector3 mousePos = Input.mousePosition; Vector3 objectPos = Camera.main.WorldToScreenPoint (body.position); mousePos.x = mousePos.x - objectPos.x; mousePos.y = mousePos.y - objectPos.y; float angle = Mathf.Atan2(mousePos.y, mousePos.x) * Mathf.Rad2Deg; body.rotation = Quaternion.Euler(new Vector3(0, 0, angle - 90)); } You might have noticed the canonballs are still moving in a straight up direction, that\u0026rsquo;s because of our hierarchy!\nhierarchyIssue If you take a look, the CanonSpawnLocation object (which is used for both deciding where to spawn the canonballs and what the direction of their movement is) is not under the body. This means that when the body rotates, the spawner does not! Let\u0026rsquo;s fixing that by moving the spawner to be under the body\nworkingTank Viola! A working moving, shooting, and rotating tank!\nEnemy Now that we have a working tank, it\u0026rsquo;s time to make a target to shoot at! ENEMIES\nLet\u0026rsquo;s start witha dummy enemy, just to shoot at\nDummy Sprite Again we need a visual representation of the enemy, let\u0026rsquo;s use the hexagon flat top default sprite from Unity! Also let\u0026rsquo;s do the same hierarchy we did with the player (Empty -\u0026gt; Body)\ndummySprite Let\u0026rsquo;s go ahead and make this a prefab for future use\nCollision So if you move the player towards the enemy or shoot at it, you\u0026rsquo;ll notice that everything goes through it. That\u0026rsquo;s because there is no notion of collision for this enemy. We can fix that by adding a collider!\nGo ahead an add a CircleCollider2D this is a circular collider for our enemy (close enough to the hexagon shape, does not need to be exact)\nenemyCollider This is not enough, colliders only work against other colliders, so we need to add colliders to our canonballs and player\nGo ahead an add a CircleCollider2D to the canonball prefab and a BoxCollider2D to our player\nNow if we launch the game, we\u0026rsquo;ll see that everything collides now!\nshootDummy Enemy Status/Logic So now we have a visual representation of the enemy, we need to give it some substance (health, damage, death)\nWe\u0026rsquo;re going to create a script for any enemy to use, but we\u0026rsquo;re going to do it in a different way. In the project tab right click and do Create -\u0026gt; C# Script and let\u0026rsquo;s call it EnemyBase this will hold logic that all enemies need\nusing UnityEngine; public class EnemyBase : MonoBehaviour { [SerializeField] private float maxHealth = 5; private float curHealth; // Start is called before the first frame update void Start() { curHealth = maxHealth; } // This runs whenever an object with a collider touches this object public void OnCollisionEnter2D(Collision2D other){ if(other.collider.tag == \u0026#34;canon\u0026#34;){ if(curHealth \u0026lt;= 1){ Destroy(this.gameObject); }else{ curHealth--; } } } } If you check in the code, we compare against a tag, this is a piece of metadata you can attach to objects, we\u0026rsquo;re going to give this metadata to our canons.\ntagCanon To test this, let\u0026rsquo;s attach it to our dummy enemy\ndummytest Awesome! We have an enemy that albiet can\u0026rsquo;t move or attack you, can take damage and die!\nSide note: We can do the same logic we used for destroying the enemy for the canonballs. In CanonballAction, we can add:\npublic void OnCollisionEnter2D(Collision2D other){ Destroy(this.gameObject); } canonDie Follow Enenmy Now with this base enenmy logic, let\u0026rsquo;s make an enemy that follows the player\nFollow Logic Let\u0026rsquo;s make a new script called FollowEnemy. It will inherit the logic from EnemyBase (health, damage, death), but we will insert new logic for following the player\nusing UnityEngine; public class FollowEnemy : EnemyBase { [SerializeField] private Transform target; [SerializeField] private float movementSpeed; // Update is called once per frame void Update() { Vector2 direction = target.position - transform.position; float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg; this.transform.rotation = Quaternion.Euler(0, 0, angle - 90); this.transform.position = transform.up * movementSpeed * Time.deltaTime + transform.position; } } This tells the enemy to look at the target and move towards it\nfollowEnemy Damaging Player Now that our enemy can follow the player, we need to let it damage the player. Let\u0026rsquo;s go back to PlayerController\npublic float maxHealth = 5; private float curHealth; public float invisTime = 2; private bool invis = false; ... public void OnTriggerStay2D(Collider2D other){ if(other.tag == \u0026#34;Enemy\u0026#34; \u0026amp;\u0026amp; !invis){ if(curHealth \u0026lt;= 1){ Debug.Log(\u0026#34;Dead!\u0026#34;); }else{ StartCoroutine(takeDamage()); } } } public IEnumerator takeDamage(){ invis = true; curHealth--; yield return new WaitForSeconds(invisTime); invis = false; } This uses a part of the colider system! Trigger! Imagine you want to detect collision without enacting the actual collision, that\u0026rsquo;s what triggers are!\nMake sure to create an Enemy tag for the Enemy GameObject and have these settings on the player object\nplayerCollision Game Manager / Singletons Now that we have a working player and a working enemy we need a way to share critical information between entities in the game and perform critical game events\nWe call these objects Managers or Singletons, they are unique objects that have no copy existing in a scene that is accessible from all scripts\nGeneral Game Manager Some things we want to do is:\nReset the level/game Spawn the player at a particular position Distribute the player\u0026rsquo;s position so all enemies can find it Whatever else we think we want to handle :3 Let\u0026rsquo;s start with creating our GameManager object(empty gameobject) along with a GameManager script:\ngamemanager using UnityEngine; using UnityEngine.SceneManagement; public class GameManager : MonoBehaviour { private static GameManager _instance; public static GameManager instance{ get{ return _instance; } } [SerializeField] private Transform playerSpawnLocation; [SerializeField] private GameObject playerObject; private Transform playerPosition; public void Awake(){ if(_instance == null){ _instance = this; DontDestroyOnLoad(this.gameObject); }else{ Destroy(this.gameObject); } } // Start is called before the first frame update void Start() { spawnPlayer(); } public Transform getPlayerPosition(){ return playerPosition; } public void spawnPlayer(){ GameObject player = Instantiate(playerObject, playerSpawnLocation.position, Quaternion.identity); playerPosition = player.transform; } public void reset(){ spawnPlayer(); } } DontDestroyOnLoad is a special method that marks a gameobject to never to be deleted when changing unity scenes (ex: changing levels).\nA static variable belongs to the class and can be accessed from anywhere, hence why we have the variable instance. This way, anyone can touch this manager and call its methods\nUpdating Existing Functions Follow Enemy If you remember, our enemy uses the transform of our player to figure out how to move towards it. Sadly this won\u0026rsquo;t work at scale since we had to manually assign the transform variable in the inspector.\nNow that we have GameManager which can return to us the player\u0026rsquo;s position, now is a great time to update that code.\nLet\u0026rsquo;s make some changes to EnemyBase and FollowEnemy:\n// EnemyBase.cs public virtual void Start() { curHealth = maxHealth; } // FollowEnemy.cs private Transform target; ... public override void Start(){ target = GameManager.instance.getPlayerPosition(); base.Start(); } // Update is called once per frame void Update() { if(target == null){ target = GameManager.instance.getPlayerPosition(); }else{ Vector2 direction = target.position - transform.position; float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg; this.transform.rotation = Quaternion.Euler(0, 0, angle - 90); this.transform.position = transform.up * movementSpeed * Time.deltaTime + transform.position; } } Player Death Currently, if you player dies, only a print statement in the console is done. Let\u0026rsquo;s reset the game if the player dies\nGoing back to PlayerController:\npublic void OnTriggerStay2D(Collider2D other){ if(other.tag == \u0026#34;Enemy\u0026#34; \u0026amp;\u0026amp; !invis){ if(curHealth \u0026lt;= 1){ GameManager.instance.reset(); Destroy(this.gameObject); }else{ StartCoroutine(takeDamage()); } } } We\u0026rsquo;ll destroy this version of the player and let the game manger handle recreating it, along with it\u0026rsquo;s details\nNow if we put multiple enemies into the scene: enemieees Everything is looking good, very promising! Of course, the game manager can be extended further in the future, but for now let\u0026rsquo;s move on\nCamera The game camera is what allows you to view what is happening in your scene. Since objects move around in a since, they will eventually move outside of the scope of the camera. But we always have things we want to never leave the frame of the camera: THE PLAYER\nCurrently the camera is stantionary, does not move at allllll. Let\u0026rsquo;s make the camera follow the the player now!\nIn our scene, we always have an object that is chosen to be the camera. In this case it is called Main Camera\ncamera Let\u0026rsquo;s add a new script to this object called CameraFollow\nusing UnityEngine; public class CameraFollow : MonoBehaviour { [SerializeField] [Range(0.005f, 0.05f)] private float followSpeed; private Transform target; // Start is called before the first frame update void Start() { target = GameManager.instance.getPlayerPosition(); } // LateUpdate gets called after Update and FixedUpdate void LateUpdate() { if(target == null){ target = GameManager.instance.getPlayerPosition(); }else{ Vector2 newPos = Vector2.Lerp(transform.position, target.position, followSpeed); transform.position = new Vector3(newPos.x, newPos.y, transform.position.z); } } } This script does a simple action of moving the position towards the player\u0026rsquo;s position at a given speed.\nAgain, with our game manager already made, grabbing the player\u0026rsquo;s position is very easy\ncameraAction UI At this point, we\u0026rsquo;ve created almost all the pieces needed before we can start making levels\nWe have a notion of health under the hood but we can\u0026rsquo;t tell that it exists on the screen. It\u0026rsquo;s time to add a UI\nHealth Bar ","date":"2022-10-16T00:00:00Z","image":"https://media.giphy.com/media/22VCh90itjL8rr5uza/giphy.gif","permalink":"/p/game-development-club-tutorial-top-down-shooter/","title":"Game Development Club Tutorial: Top Down Shooter"},{"content":"Ever heard of Unreal Engine?\nImage of Unreal Engine Logo Image from Unreal Engine 5 Teaser Quick Explanation of Unreal Unreal Engine is a 3D creation tool that primarily enables game developers to create 3D envionrments and experiences. In there own definition:\nFree to download, Unreal Engine comes with everything you need to build and ship successful multi-platform games and location-based entertainment for any genre. With full access to source code, a robust C++ API, and Blueprint visual scripting at your fingertips, you can develop your title any way you like.\nWhat Am I Doing With Unreal? Me, wanted to start a new hobby game dev project, decided to start working on a first person game! After many years of using Unity, I thought it would be a great chance to finally learn how to properly take advantage of Unreal Engine\u0026rsquo;s power! It\u0026rsquo;s known for being exclusively good for first person games.\nHow Does Unreal Work? Coding Process Unreal has 2 ways to code your games: Blueprints and C++\nBlueprints Blueprints are a visual scripting interface that allows you to code using visual building blocks. It contains parts to it that reflect what you would see when making a class in C++: functions, variables, events, components\nBlueprints exmaple C++ Coding Unreal Engine is built and compiled in C++, it comes with libraries that allow users to create their Unreal Objects, Classes, Modules, Game Systems, and more\nImage of Visual Studio Compatibility The blueprint system and C++ enviornment is designed in a way that your code can easily be converted between the two types\nImage of Blueprint to C++ option Core Components There\u0026rsquo;s more for me to learn about the core workflow of Unreal but here is what I\u0026rsquo;ve grasped.\nThere are 2 important pieces of Unreal Engine: Actors and GameModes\nActors Actors are objects that can be spawn/instantiated into the game world. It is an all encompassing role that can be any object, some examples are the camera, the player, even things that are not physical like starting location points.\nImage of Chair Actors Pawn Actors A pawn actor is a more specifc type of actor. This is an actor that can be in UE\u0026rsquo;s words possessed. I would like to say, you are able to control it during runtime to do certain actions. An example of this is the character that the player controls. The player will take control of this pawn and make it perform actions that progress the game and triggere events.\nThe entity that controls a pawn is not limited to just the player. An AI could be the one controlling the pawn, for example with enemies.\nGif of Enemy Character Actors A character actor is a varient of the pawn actor, where it\u0026rsquo;s usage is still the same, but it comes with implementations of features such as movement related to land, water, sky. It also comes with skeleton mesh components which are allow complex animations to occur with the actor and a capsule which allows collision detection and interaction with the world. This is recommended to be used for the actor that the player will control.\nCharacter Actor Example An example of a character actor can be seen from the UE5 First-Person template:\n// Copyright Epic Games, Inc. All Rights Reserved. #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameFramework/Character.h\u0026#34; #include \u0026#34;PersonalityManGameCharacter.generated.h\u0026#34; class UInputComponent; class USkeletalMeshComponent; class USceneComponent; class UCameraComponent; class UAnimMontage; class USoundBase; // Declaration of the delegate that will be called when the Primary Action is triggered // It is declared as dynamic so it can be accessed also in Blueprints DECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnUseItem); UCLASS(config=Game) class APersonalityManGameCharacter : public ACharacter { GENERATED_BODY() /** Pawn mesh: 1st person view (arms; seen only by self) */ UPROPERTY(VisibleDefaultsOnly, Category=Mesh) USkeletalMeshComponent* Mesh1P; /** First person camera */ UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \u0026#34;true\u0026#34;)) UCameraComponent* FirstPersonCameraComponent; public: APersonalityManGameCharacter(); protected: virtual void BeginPlay(); public: /** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */ UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category=\u0026#34;PlayerCameraSettings\u0026#34;) float GamepadSensitivity; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = \u0026#34;PlayerCameraSettings\u0026#34;) float MouseSensitivity; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = \u0026#34;PlayerMovementSettings\u0026#34;) float WalkSpeed; UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = \u0026#34;PlayerMovementSettings\u0026#34;) float SprintSpeed; /** Delegate to whom anyone can subscribe to receive this event */ UPROPERTY(BlueprintAssignable, Category = \u0026#34;Interaction\u0026#34;) FOnUseItem OnUseItem; protected: /** Fires a projectile. */ void OnPrimaryAction(); /** Handles moving forward/backward */ void MoveForward(float Val); /** Handles strafing movement, left and right */ void MoveRight(float Val); /** * Called via mouse input to turn at a given rate. * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate */ void MouseTurnAtRate(float Rate); /** * Called via mouse input to turn look up/down at a given rate. * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate */ void MouseLookUpRate(float Rate); /** * Called via gamepad input to turn at a given rate. * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate */ void GamePadTurnAtRate(float Rate); /** * Called via gamepad input to turn look up/down at a given rate. * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate */ void GamePadLookUpAtRate(float Rate); void SetSprint(); void SetWalk(); struct TouchData { TouchData() { bIsPressed = false;Location=FVector::ZeroVector;} bool bIsPressed; ETouchIndex::Type FingerIndex; FVector Location; bool bMoved; }; void BeginTouch(const ETouchIndex::Type FingerIndex, const FVector Location); void EndTouch(const ETouchIndex::Type FingerIndex, const FVector Location); void TouchUpdate(const ETouchIndex::Type FingerIndex, const FVector Location); TouchData\tTouchItem; protected: // APawn interface virtual void SetupPlayerInputComponent(UInputComponent* InputComponent) override; // End of APawn interface /* * Configures input for touchscreen devices if there is a valid touch interface for doing so * * @param\tInputComponent\tThe input component pointer to bind controls to * @returns true if touch controls were enabled. */ bool EnableTouchscreenMovement(UInputComponent* InputComponent); public: /** Returns Mesh1P subobject **/ USkeletalMeshComponent* GetMesh1P() const { return Mesh1P; } /** Returns FirstPersonCameraComponent subobject **/ UCameraComponent* GetFirstPersonCameraComponent() const { return FirstPersonCameraComponent; } }; GameModes The name \u0026ldquo;gamemode\u0026rdquo; is pretty self-explanitory on the use case of this module. It defines the rules of your game and \u0026ldquo;what\u0026rdquo; the game is. Some examples are \u0026ldquo;how is the player spawned into the game\u0026rdquo;, \u0026ldquo;what systems are spawn\u0026rdquo;, \u0026ldquo;how many players can be in the game at once\u0026rdquo;, the list goes on.\nWhile certain fundamentals, like the number of players required to play, or the method by which those players join the game, are common to many types of games, limitless rule variations are possible depending on the specific game you are developing. Regardless of what those rules are, Game Modes are designed to define and implement them. There are currently two commonly-used base classes for Game Modes. - Unreal Engine Documentation\nAn example of a gamemode can be seen from the UE5 First-Person template:\n// Copyright Epic Games, Inc. All Rights Reserved. #pragma once #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;GameFramework/GameModeBase.h\u0026#34; #include \u0026#34;PersonalityManGameGameMode.generated.h\u0026#34; UCLASS(minimalapi) class APersonalityManGameGameMode : public AGameModeBase { GENERATED_BODY() public: APersonalityManGameGameMode(); }; // Copyright Epic Games, Inc. All Rights Reserved. #include \u0026#34;PersonalityManGameGameMode.h\u0026#34; #include \u0026#34;PersonalityManGameCharacter.h\u0026#34; #include \u0026#34;UObject/ConstructorHelpers.h\u0026#34; APersonalityManGameGameMode::APersonalityManGameGameMode() : Super() { // set default pawn class to our Blueprinted character static ConstructorHelpers::FClassFinder\u0026lt;APawn\u0026gt; PlayerPawnClassFinder(TEXT(\u0026#34;/Game/FirstPerson/Blueprints/BP_FirstPersonCharacter\u0026#34;)); DefaultPawnClass = PlayerPawnClassFinder.Class; } That\u0026rsquo;s It For Now! That\u0026rsquo;s all the information I\u0026rsquo;ve acculmulated so far, look out for the next blog where I start working on that first-person project, specifically the movement system!\n","date":"2022-08-27T00:00:00Z","image":"https://media.giphy.com/media/22VCh90itjL8rr5uza/giphy.gif","permalink":"/p/my-unreal-adventure-blog-1-unreal-engine-intro/","title":"My Unreal Adventure! Blog 1: Unreal Engine Intro"},{"content":"I\u0026rsquo;ve been exploring Direct X 3D and it\u0026rsquo;s implementation as a Graphics Engine! Wanted to share my notes on how to set it up in a quick and simple blog.\nThere is a bunch of overhead involving creating a window before setuping Direct X 3D, I will not be covering it in this blog, but plan to cover it in another blog.\nAll the code related to the contents of this blog come from my repository on Github\nDirect X Pipeline Before rendering an object in Direct X, there are components that need to be initialized:\nDevice Swap Chain Context Device The device is a component of Direct3D that allows you to allocate data structures and store information on the GPU about the current rendering state\nExamples of uses of the device are:\nRenderTargetView DepthStencilState CreateTexture2D CreateBuffer CreateVertexShader CreatePixelShader CreateInputLayout For more information about the device\nSwap Chain The swap chain represent the current frame being presented to you, the viewer. The swap chain has a lot of settings that can be adjusted but the idea is that you have two(or more) buffers, the front and back buffers.\nThe names front and back represent which buffer is the one being presented. The back buffer will be where current draw calls are being directed to while the front buffer will be what the viewer sees.\nOnce the drawing of the back buffer has been completed, the buffers will be switched and the previous back buffer will be the current front buffer while the previous front buffer will be the current back buffer\nA representation of a triple buffer swap chain For more information about the swap chain\nContext The context holds all the resources being used in pipeline:\nVertexBuffer : A collection of vertex data of the current object IndexBuffer : A collection of indexes representing the order of verticies to use when drawing the desired topology shape VerexShader : GPU instructions used to perform mathmatical operations to each vertex positioning before presentation PixelShader : GPU instructions used to perform mathmatical operations to each vertex coloring before presentation Topology : The geometric shape to use when rendering verticies (EX: Lines \u0026amp; Triangles) InputLayout : A definition of the low level layout of data being sent to the GPU and their shaders (Vertex Data Definition, Color Data Definition, etc) ConstantBuffer : A buffer that is filled with custom data and available to the designated shader at all times. (Data can only be updated by replacing the buffer with an updated version) The context allows you to attach created data structures(listed above) and attach them to the current render pipeline\nFor more information about the context\nExtra There are more parts of the pipeline not covered in this readme\nImage of Direct3D Pipeline For more information of the pipeline\nCreating an Object Creating an object involves a combination of using the device to allocate data structures(like buffers) and using the context to attach them to the pipeline. Every object must go through creating, defining, and attaching pipeline resources before being raterized to the swap chain buffers\nExample of creating a box struct Vertex { struct { float x; float y; float z; } pos;\t}; ////Create Vertex Buffer (2d Triangle) const Vertex vertices[] = { {-1.0f, -1.0f, -1.0f}, {1.0f, -1.0f, -1.0f}, {-1.0f, 1.0f, -1.0f}, {1.0f, 1.0f, -1.0f}, {-1.0f, -1.0f, 1.0f}, {1.0f, -1.0f, 1.0f}, {-1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f} }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pVertexBuffer; D3D11_BUFFER_DESC bd = {}; bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; bd.Usage = D3D11_USAGE_DEFAULT; bd.CPUAccessFlags = 0u; bd.MiscFlags = 0u; bd.ByteWidth = sizeof(vertices); bd.StructureByteStride = sizeof(Vertex); D3D11_SUBRESOURCE_DATA sd = {}; sd.pSysMem = vertices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;bd, \u0026amp;sd, \u0026amp;pVertexBuffer)); //// Attach Vertex Buffer to Pipeline const UINT stride = sizeof(Vertex); const UINT offset = 0u; pContext-\u0026gt;IASetVertexBuffers(0u,1u, pVertexBuffer.GetAddressOf(), \u0026amp;stride, \u0026amp;offset); //// Create Index Buffer (Used for reusing predfined vertices for multiple triangles) const unsigned short indices[] = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4, }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pIndexBuffer; D3D11_BUFFER_DESC ibd = {}; ibd.BindFlags = D3D11_BIND_INDEX_BUFFER; ibd.Usage = D3D11_USAGE_DEFAULT; ibd.CPUAccessFlags = 0u; ibd.MiscFlags = 0u; ibd.ByteWidth = sizeof(indices); ibd.StructureByteStride = sizeof(unsigned short); D3D11_SUBRESOURCE_DATA isd = {}; isd.pSysMem = indices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;ibd, \u0026amp;isd, \u0026amp;pIndexBuffer)); //// Attach Index Buffer to Pipeline pContext-\u0026gt;IASetIndexBuffer(pIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0u); //// Create const buffer for transformation matrix (Do matrix transformation instead of moving sending a new vertex buffer) struct ConstantBuffer { dx::XMMATRIX transform; }; const ConstantBuffer cb = { { dx::XMMatrixTranspose( dx::XMMatrixRotationZ(angle) * dx::XMMatrixRotationX(angle) * dx::XMMatrixTranslation(x, 0.0f, z + 4.0f) * dx::XMMatrixPerspectiveLH(1.0f, 3.0f/ 4.0f, 0.5f, 10.0f) ) } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer; D3D11_BUFFER_DESC cbd = {}; cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd.Usage = D3D11_USAGE_DYNAMIC; cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; cbd.MiscFlags = 0u; cbd.ByteWidth = sizeof(cb); cbd.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd = {}; csd.pSysMem = \u0026amp;cb; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd, \u0026amp;csd, \u0026amp;pConstantBuffer)); //// Attach const buffer to vertex shader pContext-\u0026gt;VSSetConstantBuffers(0u, 1u, pConstantBuffer.GetAddressOf()); //// Create another constant buffer for tagging triangle indexes to colors (individual colors per cube face) struct ConstantBuffer2 { struct { float r; float g; float b; float a; }face_colors[6]; }; const ConstantBuffer2 cb2 = { { {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 1.0f}, } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer2; D3D11_BUFFER_DESC cbd2 = {}; cbd2.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd2.Usage = D3D11_USAGE_DEFAULT; cbd2.CPUAccessFlags = 0u; cbd2.MiscFlags = 0u; cbd2.ByteWidth = sizeof(cb2); cbd2.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd2 = {}; csd2.pSysMem = \u0026amp;cb2; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd2, \u0026amp;csd2, \u0026amp;pConstantBuffer2)); //// Attach const buffer to vertex shader pContext-\u0026gt;PSSetConstantBuffers(0u, 1u, pConstantBuffer2.GetAddressOf()); //// Create Pixel Shader wrl::ComPtr\u0026lt;ID3D11PixelShader\u0026gt; pPixelShader; wrl::ComPtr\u0026lt;ID3DBlob\u0026gt; pBlob; GFX_THROW_INFO(D3DReadFileToBlob(L\u0026#34;PixelShader.cso\u0026#34;, \u0026amp;pBlob)); GFX_THROW_INFO(pDevice-\u0026gt;CreatePixelShader(pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), nullptr, \u0026amp;pPixelShader)); //// Attach Pixel Shader pContext-\u0026gt;PSSetShader(pPixelShader.Get(), nullptr, 0u); // Create Vertex Shader wrl::ComPtr\u0026lt;ID3D11VertexShader\u0026gt; pVertexShader; GFX_THROW_INFO(D3DReadFileToBlob(L\u0026#34;VertexShader.cso\u0026#34;, \u0026amp;pBlob)); GFX_THROW_INFO(pDevice-\u0026gt;CreateVertexShader(pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), nullptr, \u0026amp;pVertexShader)); // Attach Vertex Shader to Pipeline //pContext-\u0026gt;VSSetShader(pVertexShader.Get(), nullptr, 0u); //// Input (vertex) layout (2d position only) wrl::ComPtr\u0026lt;ID3D11InputLayout\u0026gt; pInputLayout; const D3D11_INPUT_ELEMENT_DESC ied[] = { //\t// Reads positions as 2 4 byte values {\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, //\t// Reads color as 4 byte values and normalizes them from 0 - 1 {\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; GFX_THROW_INFO(pDevice-\u0026gt;CreateInputLayout( ied, (UINT)std::size(ied), pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), \u0026amp;pInputLayout )); //// Bind Input Layout pContext-\u0026gt;IASetInputLayout(pInputLayout.Get()); // Bind Render Target // **COME BACK TO THIS IN CASE ERROR** pContext-\u0026gt;OMSetRenderTargets(1u, pTarget.GetAddressOf(), pDSV.Get()); // Set primitive topology to triangle list (groups of verticies make multiple triangles) pContext-\u0026gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); GFX_THROW_INFO_ONLY(pContext-\u0026gt;DrawIndexed(count, 0u, 0u)); Vertex Buffer Device Step\nstruct Vertex { struct { float x; float y; float z; } pos;\t}; ////Create Vertex Buffer (2d Triangle) const Vertex vertices[] = { {-1.0f, -1.0f, -1.0f}, {1.0f, -1.0f, -1.0f}, {-1.0f, 1.0f, -1.0f}, {1.0f, 1.0f, -1.0f}, {-1.0f, -1.0f, 1.0f}, {1.0f, -1.0f, 1.0f}, {-1.0f, 1.0f, 1.0f}, {1.0f, 1.0f, 1.0f} }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pVertexBuffer; D3D11_BUFFER_DESC bd = {}; bd.BindFlags = D3D11_BIND_VERTEX_BUFFER; bd.Usage = D3D11_USAGE_DEFAULT; bd.CPUAccessFlags = 0u; bd.MiscFlags = 0u; bd.ByteWidth = sizeof(vertices); bd.StructureByteStride = sizeof(Vertex); D3D11_SUBRESOURCE_DATA sd = {}; sd.pSysMem = vertices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;bd, \u0026amp;sd, \u0026amp;pVertexBuffer)); Context Step\n//// Attach Vertex Buffer to Pipeline const UINT stride = sizeof(Vertex); const UINT offset = 0u; pContext-\u0026gt;IASetVertexBuffers(0u,1u, pVertexBuffer.GetAddressOf(), \u0026amp;stride, \u0026amp;offset); Index Buffer Device Step\n//// Create Index Buffer (Used for reusing predfined vertices for multiple triangles) const unsigned short indices[] = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4, }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pIndexBuffer; D3D11_BUFFER_DESC ibd = {}; ibd.BindFlags = D3D11_BIND_INDEX_BUFFER; ibd.Usage = D3D11_USAGE_DEFAULT; ibd.CPUAccessFlags = 0u; ibd.MiscFlags = 0u; ibd.ByteWidth = sizeof(indices); ibd.StructureByteStride = sizeof(unsigned short); D3D11_SUBRESOURCE_DATA isd = {}; isd.pSysMem = indices; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;ibd, \u0026amp;isd, \u0026amp;pIndexBuffer)); Context Step\n//// Attach Index Buffer to Pipeline pContext-\u0026gt;IASetIndexBuffer(pIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0u); Constant Buffers (Vertex and Pixel) Device Step\n//// Create const buffer for transformation matrix (Do matrix transformation instead of moving sending a new vertex buffer) struct ConstantBuffer { dx::XMMATRIX transform; }; const ConstantBuffer cb = { { dx::XMMatrixTranspose( dx::XMMatrixRotationZ(angle) * dx::XMMatrixRotationX(angle) * dx::XMMatrixTranslation(x, 0.0f, z + 4.0f) * dx::XMMatrixPerspectiveLH(1.0f, 3.0f/ 4.0f, 0.5f, 10.0f) ) } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer; D3D11_BUFFER_DESC cbd = {}; cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd.Usage = D3D11_USAGE_DYNAMIC; cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE; cbd.MiscFlags = 0u; cbd.ByteWidth = sizeof(cb); cbd.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd = {}; csd.pSysMem = \u0026amp;cb; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd, \u0026amp;csd, \u0026amp;pConstantBuffer)); Context Step\n//// Attach const buffer to vertex shader pContext-\u0026gt;VSSetConstantBuffers(0u, 1u, pConstantBuffer.GetAddressOf()); Device Step\n//// Create another constant buffer for tagging triangle indexes to colors (individual colors per cube face) struct ConstantBuffer2 { struct { float r; float g; float b; float a; }face_colors[6]; }; const ConstantBuffer2 cb2 = { { {1.0f, 0.0f, 1.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 1.0f}, } }; wrl::ComPtr\u0026lt;ID3D11Buffer\u0026gt; pConstantBuffer2; D3D11_BUFFER_DESC cbd2 = {}; cbd2.BindFlags = D3D11_BIND_CONSTANT_BUFFER; cbd2.Usage = D3D11_USAGE_DEFAULT; cbd2.CPUAccessFlags = 0u; cbd2.MiscFlags = 0u; cbd2.ByteWidth = sizeof(cb2); cbd2.StructureByteStride = 0u; D3D11_SUBRESOURCE_DATA csd2 = {}; csd2.pSysMem = \u0026amp;cb2; GFX_THROW_INFO(pDevice-\u0026gt;CreateBuffer(\u0026amp;cbd2, \u0026amp;csd2, \u0026amp;pConstantBuffer2)); Context Step\n//// Attach const buffer to vertex shader pContext-\u0026gt;PSSetConstantBuffers(0u, 1u, pConstantBuffer2.GetAddressOf()); Input Layout Device Step\n//// Input (vertex) layout (2d position only) wrl::ComPtr\u0026lt;ID3D11InputLayout\u0026gt; pInputLayout; const D3D11_INPUT_ELEMENT_DESC ied[] = { //\t// Reads positions as 2 4 byte values {\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, //\t// Reads color as 4 byte values and normalizes them from 0 - 1 {\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; GFX_THROW_INFO(pDevice-\u0026gt;CreateInputLayout( ied, (UINT)std::size(ied), pBlob-\u0026gt;GetBufferPointer(), pBlob-\u0026gt;GetBufferSize(), \u0026amp;pInputLayout )); Context Step\n//// Bind Input Layout pContext-\u0026gt;IASetInputLayout(pInputLayout.Get()); Topology Context Step\n// Set primitive topology to triangle list (groups of verticies make multiple triangles) pContext-\u0026gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST); Drawable \u0026amp; Bindable Framework Design The Drawable \u0026amp; Bindable Graphics framework was designed by PlanetChilli (Otherwise known as ChiliTomatoNoodle on yt)\nThe framework is designed to shorten and abstract the creation of objects in DirectX. There are 3 parts of it, the Graphics interface, the Bindable Interface, and the Drawable Interface. These all work together to allow multiple object creation in a single 3D scene\nGraphics This interface is the main controller of 3D scene\nPipeline setup This interface will handle the creation of the crucial components of the pipeline (Device, Swap Chain, Context)\nAlong with that, it will keep a reference to:\nDevice Swap Chain Context RenderTargetView : A pipeline handled data structure for referencing the current back buffer DepthStencilView : A pipeline handled data structure for referncing the current depth view frame A projection matrix : Used for translating the vertex position to 3D camera space (perspective, orthographic) There are also five key functions to the Graphics interface:\nEndFrame() : Presents the current back buffer by switching the front and back buffer ClearBuffer() : Wipes everything on the current back buffer DrawIndex() : Draws onto the back buffer with the resources attached to the pipeline (assumes that indexing is done, can be changed to work without indexing) SetProjection() : Updates the current projection matrix in the 3D Scene GetProjection() : Returns the current project matrix being used in the 3D scene Bindable This interface represents one of the data structures that can be attached to the pipline\nSome examples of Bindable structures are:\nVertexBuffer ConstantBuffers IndexBuffer InputLayout Shaders (Vertex and Pixel) Topology etc The only function required of a Bindable is called Bind(). The expected implementation is that the context step of attaching to the pipeline is done in this function while the device step is handled in the constructor.\nHelper Functions There are helper functions that only Bindable objects can call, these are implemented by the Bindable interface and allow Bindables to interact with the Graphics instance:\nGetContext() : Returns the current reference to the Context of a Graphics instance GetDevice() : Returns the current reference to the Device of a Graphics instance Drawable This interface represents a drawable object such as a Box, Triangle, or any other 3D(or 2D) object\nThere are 5 functions tied to a Drawable:\nGetTransformXM() : Returns the current transformation matrix of the object (rotation + translation + etc, excluding the projection matrix stored in Graphics) Draw() : Binds the Drawable\u0026rsquo;s bindables to the pipeline and tells the Graphics instance to draw it AddBind() : Adds a bindable to the Drawable\u0026rsquo;s collection AddIndexBuffer() : Performs the same as AddBind() except with the condition that only 1 IndexBuffer can be added to a Drawable object Update() : Performs changes to a Drawable\u0026rsquo;s state based off a change of time (movement, rotation, scaling, etc) The Drawable interface already implements the crucial functions listed, new Drawables will only need to implement certain functions due to behavior varying between Drawables:\nGetTransformXM() Update() The expected behavior is that creating Bindables and adding them to Drawables are done in a Drawable constructor\nExample of the Drawable \u0026amp; Bindable Framework Box.h\n#include \u0026#34;Drawable.h\u0026#34; class Box : public Drawable { public: Box(Graphics\u0026amp; gfx, std::mt19937\u0026amp; rng, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; adist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; ddist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; odist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; rdist); void Update(float dt) noexcept override; DirectX::XMMATRIX GetTransformXM() const noexcept override; private: float r; // z-axis float roll = 0.0f; // x-axis float pitch = 0.0f; // y-axis float yaw = 0.0f; float theta; float phi; float chi; // z-axis float droll; // x-axis float dpitch; // y-axis float dyaw; float dtheta; float dphi; float dchi; }; Box.cpp (constructor)\nBox::Box(Graphics\u0026amp; gfx, std::mt19937\u0026amp; rng, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; adist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; ddist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; odist, std::uniform_real_distribution\u0026lt;float\u0026gt;\u0026amp; rdist) : r(rdist(rng)), droll(ddist(rng)), dpitch(ddist(rng)), dyaw(ddist(rng)), dphi(odist(rng)), dtheta(odist(rng)), dchi(odist(rng)), chi(adist(rng)), theta(adist(rng)), phi(adist(rng)) { struct Vertex { struct { float x; float y; float z; }pos; struct { unsigned char r; unsigned char g; unsigned char b; }color; }; const std::vector\u0026lt;Vertex\u0026gt; vertices = { {-1.0f, -1.0f, -1.0f, 255,0,255 }, {1.0f, -1.0f, -1.0f, 255,0,0 }, {-1.0f, 1.0f, -1.0f, 0,255,0}, {1.0f, 1.0f, -1.0f, 0,0,255}, {-1.0f, -1.0f, 1.0f, 255,255,0}, {1.0f, -1.0f, 1.0f, 0,255,255}, {-1.0f, 1.0f, 1.0f, 255,255,255}, {1.0f, 1.0f, 1.0f, 0,255,255} }; AddBind(std::make_unique\u0026lt;VertexBuffer\u0026lt;Vertex\u0026gt;\u0026gt;(gfx, vertices)); auto pvs = std::make_unique\u0026lt;VertexShader\u0026gt;(gfx, L\u0026#34;VertexShader.cso\u0026#34;); auto pvbc = pvs-\u0026gt;GetByteCode(); AddBind(std::move(pvs)); AddBind(std::make_unique\u0026lt;PixelShader\u0026gt;(gfx, L\u0026#34;PixelShader.cso\u0026#34;)); const std::vector\u0026lt;unsigned short\u0026gt; indices = { 0,2,1, 2,3,1, 1,3,5, 3,7,5, 2,6,3, 3,6,7, 4,5,7, 4,7,6, 0,4,2, 2,4,6, 0,1,4, 1,5,4 }; AddIndexBuffer(std::make_unique\u0026lt;IndexBuffer\u0026gt;(gfx, indices)); struct FaceColorConstantBuffer { struct { float r; float g; float b; float a; }face_colors[6]; }; const std::vector\u0026lt;D3D11_INPUT_ELEMENT_DESC\u0026gt; ied = { {\u0026#34;POSITION\u0026#34;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0}, {\u0026#34;COLOR\u0026#34;, 0, DXGI_FORMAT_R8G8B8A8_UNORM, 0, D3D11_APPEND_ALIGNED_ELEMENT, D3D11_INPUT_PER_VERTEX_DATA, 0} }; AddBind(std::make_unique\u0026lt;InputLayout\u0026gt;(gfx, ied, pvbc)); AddBind(std::make_unique\u0026lt;Topology\u0026gt;(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST)); AddBind(std::make_unique\u0026lt;TransformConstantBuffer\u0026gt;(gfx, *this)); } Box.cpp (Update)\nvoid Box::Update(float dt) noexcept { roll += droll * dt; pitch += dpitch * dt; yaw += dyaw * dt; phi += dphi * dt; chi += dchi * dt; } Box.cpp (GetTransformXM)\nDirectX::XMMATRIX Box::GetTransformXM() const noexcept { return DirectX::XMMatrixRotationRollPitchYaw(pitch, yaw, roll) * DirectX::XMMatrixTranslation(r, 0.0f, 0.0f)* DirectX::XMMatrixRotationRollPitchYaw(theta, phi, chi)* DirectX::XMMatrixTranslation(0.0f, 0.0f, 20.0f); } Main\nstd::mt19937 rng(std::random_device{}()); std::uniform_real_distribution\u0026lt;float\u0026gt; adist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; ddist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; odist(0.0f, 3.1415f * 2.0f); std::uniform_real_distribution\u0026lt;float\u0026gt; rdist(6.0f, 20.0f); for (auto i = 0; i \u0026lt; 150; i++) { boxes.push_back(std::make_unique\u0026lt;Box\u0026gt;( (Graphics instance here), rng, adist, ddist, odist, rdist )); } (Graphics instance here).SetProjecton(DirectX::XMMatrixPerspectiveLH(1.0, 3.0f / 4.0f, 0.5f, 40.0f)); Some other function that executes a frame\nauto dt = timer.Mark(); (Graphics instance here).ClearBuffer(0.07f, 0.0f, 0.12f); for (auto\u0026amp; b : boxes) { b-\u0026gt;Update(dt/8); b-\u0026gt;Draw((Graphics instance here)); } (Graphics instance here).EndFrame(); Result of Code GIF Source Link\n","date":"2021-12-22T18:11:43-08:00","image":"https://media.giphy.com/media/hVsP8KfbcwItVhMg5s/giphy.gif","permalink":"/p/directx-3d-intro/","title":"DirectX 3D Intro"}]